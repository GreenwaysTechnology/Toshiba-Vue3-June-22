			   Vue-js
....................................................................................

What is Vue?
 Vue is java script framework for building User interface apps on the client(browser)
 Vue takes responsiblity of changing html page on fly.DOM Programming.

HTML:
What is HTML?

How HTML is represented inside browser?

What angular/react/vue is doing with HTML?

If you look at any web technology, either server side or client side.
  HTML is common

Server side technologies like JEE(Servlet),ASP.net,PHP , Create HTML Pages on fly -dynamic web page.

Client side technologies like javascript , Processing rendered html(accessing html elements),
javascript can be used to create "HTML pages on fly" like server side technologies.
............................................................................................
				Internals of HTML Representation
..........................................................................................

HTML is programming language -  DSL pl /declarative pl.

index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
-------------------Browser
loader---LOAD Code into browser
 |
   from file: or http:
 |
Parser : Parser is special compiler which converts source into lexcial tree(string tree)
 |
body
  div
     h1
        Welcome 
     h1
  div
body
|
 Complier-Compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body
..............................................................................................
				Runtime  -  Allocate Memory for HTML
...........................................................................................				
HTML Execution engine : Request Os ,to allocate memory :Runtime

-LinkedList - c

body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body

-Nodes are connected each other in hierachical structure(tree)
 
Linking the Nodes: Tree

body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
body
 |
 |
Layout/Paint Engine: will convert nodes into pxs : final output
.............................................................................................
				 Birth of Java Script
.............................................................................................

..............................................................................................
				Dynamic HTML - Inside Web Browser
.............................................................................................

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?
  
One spec was published ,As per that spec
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be reprsented as Objects" : Object oriented Document Programming.
..............................................................................................
				Birth of Frameworks and libs



............................................................................................
How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                 Every Html ELEMENT Inside Browser is "C Program"

	       Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.	*******************************************************************************************	
.............................................................................................
				DOM Programming
.............................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.. 2008(Angular js) 2013(react)...

Popular DOM frameworks/lib:
1.React
2.Angular
3.Vue.js
.....................................................................................
                           Types of Javascript apps(IN UI)
			    (Styles of DOM Programming)
				   (Vue)
.....................................................................................

1.Standalone Script

Vue can be used as a standalone script file - no build step required! If you have a backend framework already rendering most of the HTML, or your frontend logic isn't complex enough to justify a build step, this is the easiest way to integrate Vue into your stack. You can think of Vue as a more declarative replacement of jQuery in such cases


=>It is old model of writing code.
=>server always creates html pages , sends html to browser
=>Client side we need to submit forms
   we need to validate the forms-js can be used.
   some animations 
   if you want to submit forms to the server for processing some data
   (ajax)

Technologies:
  jQuery


2.Single-Page Application (SPA):
Some applications require rich interactivity and non-trivial stateful logic on the frontend. The best way to build such applications is to use an architecture where Vue not only controls the entire page, but also handles data updates and navigation without having to reload the page. This type of application is typically referred to as a Single-Page Application (SPA).

SPAs typically require the backend to expose API endpoints - but you can also pair Vue with solutions like Inertia.js to get the SPA benefits while retaining a server-centric development model.

Fullstack / SSR

Pure client-side SPAs are problematic when the app is sensitive to SEO and time-to-content. This is because the browser will receive a largely empty HTML page, and has to wait until the JavaScript is loaded before rendering anything.

Vue provides first-class APIs to "render" a Vue app into HTML strings on the server. This allows the server to send back already-rendered HTML, allowing end users to see the content immediately while the JavaScript is being downloaded. Vue will then "hydrate" the application on the client side to make it interactive. This is called Server-Side Rendering (SSR) and it greatly improves Core Web Vital metrics such as Largest Contentful Paint (LCP).

There are higher-level Vue-based frameworks built on top of this paradigm, such as Nuxt, which allow you to develop a fullstack application using Vue and JavaScript.


JAMStack / SSG#
Server-side rendering can be done ahead of time if the required data is static. This means we can pre-render an entire application into HTML and serve them as static files. This improves site performance and makes deployment a lot simpler since we no longer need to dynamically render pages on each request. Vue can still hydrate such applications to provide rich interactivity on the client. This technique is commonly referred to as Static-Site Generation (SSG), also known as JAMStack.

The Vue team maintains a static-site generator called VitePress, which powers this website you are reading right now! In addition, Nuxt also supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.


Beyond the Web:
...............

Although Vue is primarily designed for building web applications, it is by no means limited to just the browser. You can:

Build desktop apps with Electron or Tauri
Build mobile apps with Ionic Vue
Build desktop and mobile apps from the same codebase with Quasar
Use Vue's Custom Renderer API to build custom renderers targeting WebGL or even the terminal!

App selections:

Whether your app is legacy server side apps built using j2ee or .net,php,rails--->
 Standalone vue.js

Your app is api centeric(webservices)/microservices

Vue can be used as "SPA"

SPA With SSR for better optimization and SEO ready

SPA and SSR With SSG/JAM Stack - where your app is having static data

Getting started with Vue:
........................

Project Setup:
..............

1.without build tools

2.with build tools


1.without build tools

Steps:

1.create Project

>mkdir vue-legacy

vue-legacy>mkdir src

create index.html outside src dir

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
</head>
<body>
    
</body>
</html>

in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build


Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.


Prod Build
 <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
    <!-- This is dev build -->
    <script src="https://unpkg.com/vue@3"></script>
    <!-- This is production build -->
    <!-- <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script> -->
</head>
<body>
   
</body>

</html>
....................................................................................
				Vue Application
....................................................................................

Vue is just javascript framework, offers apis,infrastructure to build "DOM" programming.

DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.


Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

   <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('create Element')
            const Heading = document.createElement('h1')
            Heading.innerHTML = 'Hello DOM!'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement();
    </script>

2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates

Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
			   java script => binds the state(data)


How Vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue Organizes the UI into Smaller and Small UI
=>Vue Breaks complex UI into Smaller UI
   This model is called Composition

Why Composition?
=>The UI can be reused any where in the app.
=>The code maintaince is very easy,because it is independant.

           This arch is called as "component driven arch"

What is component?
   Component is object

Any Object has three things

1.state - data associated with object
2.behaviour - methods are associated with object, which updates the state.
3.identity -  every object is unquie

Component has even extra features
1.User interface
   Object has visibility.

Component is term introduced by MicroSoft early 90s, in order to differentiate UI elments from back end objects.
.....................................................................................
			    Components
.....................................................................................
Vue is component driven framework, in vue , we have to create components.

Before creating components, we need to have "VUE runtime".

Vue Runtime is added or bootstraped as soon as we add script having vue.js framework 


Steps:

1.create Application Object

Pro Vue 3.
var app = new Vue({   })
    
Vue 3:

1.1.Get Vue Instance

We can get Vue Instance 

A.Via Global Vue variable
B.Via ES 6 modules

....................................................................................
			A.Via Global Vue variable
...................................................................................

Vue is Root Instance having lot methods (factory methods)

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 

etc..

1.2. call method called createApp

Creates an application instance.

function createApp(rootComponent: Component, rootProps?: object): App

const app = createApp()

console.log(app)

Application Object methods:
............................

component: ƒ component(name, component)
config: (...)
directive: ƒ directive(name, directive)
mixin: ƒ mixin(mixin)
mount: (containerOrSelector) => {…}
provide: ƒ provide(key, value)
unmount: ƒ unmount()
use: ƒ use(plugin, ...options)
version: "3.2.36"
_component: {}
_container: null
_context: {app: {…}, config: {…}, mixins: Array(0), components: {…}, directives: {…}, …}
_instance: null
_props: null
_uid: 0


       //way -1
        //     //get Vue Instance
        //  const vue  = Vue
        // // console.log(vue)
        // const app = vue.createApp()
        // console.log(app)
        //way -2
        // const app = Vue.createApp()
        // console.log(app)
        //way - 3 : es 6 destructuring syntax
        const { createApp } = Vue
        const app = createApp()
        console.log(app)
.....................................................................................
				B.Via ES 6 modules
....................................................................................

Scripts should imported using "importmap" of script tag

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E6 Modules-without Build tools</title>
    <!-- Poly file for import maps -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
</head>

<body>
    <div id="app">

    </div>
    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
    <script type="module">
        import { createApp } from 'vue'
        const app = createApp()
        console.log(app)
    </script>

</body>

</html>


Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.

    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>

Not for production

The import-maps-based setup is meant for learning only - if you intend to use Vue without build tools in production, make sure to check out the Production Deployment Guide.
....................................................................................
			 Root Component
....................................................................................

Component is object represented as literal object.

const rootComponent = {

}

What component contains:
Component information can be categoriezied into various segments

UI/Rendering

1.template
2.render
3.compilerOptions 


State:

1.data
2.props
3.computed
4.methods
5.watch
6.emits
7.expose

LifeCycles
............
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered
activated
deactivated
serverPrefetch

Composition

1.provide
2.inject
3.mixins
4.extends

Misc

name
inheritAttrs
components
directives

Component Instance

$data
$props
$el
$options
$parent
$root
$slots
$refs
$attrs
$watch()
$emit()
$forceUpdate()
$nextTick()
....................................................................................

Template:
 => It is html along with some special instructions
 => It is compiled into sequence of java script methods by vue compilers
 => Every component will have template
 => root component uses container element as template

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Root Component</title>
  <!-- Poly file for import maps -->
  <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
  <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
</head>

<body>
  <div id="app">

  </div>

  <script type="module">
    import { createApp } from 'vue'

    const rootComponent = {
      template: `
             <h1>Welcome to Vue App</h1>
             <p>How are you?</p>
      `
    }
    const app = createApp(rootComponent)

    //rendering root Component on existing dom tree
    app.mount('#app')
  </script>

</body>

</html>
...................................................................................
			  How to write modular code

1.you have to write application componet in a separate folders and files

src
 |
 components
    |
    App.js
index.html

src/App.js
export default {
    template: `
        <div>
             <h1>Vue App</h1>
        </div>
    `
}
index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Root Component</title>
    <!-- Poly file for import maps -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
</head>

<body>
    <div id="app">

    </div>

    <script type="module">
        import { createApp } from 'vue'
        import App from './src/App.js'
        createApp(App).mount('#app')
    </script>

</body>

</html>

.....................................................................................
			How to setup vue Apps using Build Tools
.....................................................................................

Tool for creating and Managining vue app life cycles


vue-cli
 old pattern
vite
 modern pattern - recommended
 npm init vue@latest

This is abstraction for vite based project templates

>npm init vue@latest
Need to install the following packages:
  create-vue@latest
Ok to proceed? (y) y

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-modern
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add Cypress for both Unit and End-to-End testing? ... No / Yes
√ Add ESLint for code quality? ... No / Yes
√ Add Prettier for code formatting? ... No / Yes

Scaffolding project in E:\session\Toshiba\vue-session\vue-modern...

Done. Now run:

  cd vue-modern
  npm install
  npm run lint
  npm run dev
....................................................................................
				Component Creational Pattern
....................................................................................

1.Plain Java script Pattern

App.js
export default {
  
  ...options 
  
}

2.Single File Components -SFC

 It is more declarative way of creating components
 As name suggest, All Component logic inside single file.

Component has three major sections

1.template
2.javascript
3.style

In SFC Pattern, we isloate very clearly into three sections

<script>
   ....All javascript code
</script>
<template>
  ...template code
</template>
<style>
 //style for this component
</style>


Plain javascript pattern is usefull where there is no build workflow,SFC is usefull and necessary in build tool work flow 

SFC components are saved with fileName.vue
....................................................................................
                                SFC API styles
...................................................................................

				SFC Component
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api



Commonality between both patterns

1.code segementation is same
  <script></script>
  <template></template>
  <style></style>


Options Api Style Pattern:
<!-- Options Api Pattern -->
<script>
//you have to return options object
export default {

}
</script>
<template>
  <h1>Welcome to Vue App-Using SFC On Options Object Pattern</h1>
</template>
<style>
</style>


Compostion Api Pattern:
<!-- Compostion api Pattern  -->
<script setup>
 //java script code can go directly
 
</script>
<template>
  <h1>Single File Component using Composition Api Pattern</h1>
</template>
<style>
</style>
.....................................................................................
				Component Composition


Single File Component(SFC)
.........................

SFC can be written in two styles

1.Using options api

2.Using Composition api


App.vue
<script>
import Greeter from "./components/Greeter.vue";
export default {
    components: { Greeter }
}
</script>
<template>
   <h1>Vue Application</h1>
   <Greeter></Greeter>
</template>

Greeter.vue
<script>
</script>
<template>
    <h1>Greeter</h1>
</template>

Welcome.vue
<script>
</script>
<template>
    <h1>Welcome</h1>
</template>

What if i want to visualize the tree model created by vue?

Dev tools: Vue dev tool
https://devtools.vuejs.org/

.................................................................................
			   Project layout

In general Projects can be categorized into  2 sections

1.feature based
products
customers
inventory
payment
etc...
2.framework based
src/
 components
    ....
Feature + framework
 
 components
    |
    features

components
  |
  products
    products-list.vue
    products-edit.vue
    products-search.vue

eg:

src/App.vue
<script setup>
import Header from './components/layouts/Header.vue';
import Footer from './components/layouts/Footer.vue';
import Body from './components/layouts/Body.vue';
</script>
<template>
    <div>
        <Header></Header>
        <Body></Body>
        <Footer></Footer>
    </div>
</template>

src/components/layout

Body.vue
<script setup>
import Greeter from '../greeter/Greeter.vue';
</script>
<template>
    <div>
        <Greeter></Greeter>
        <p>
            What is the best way to structure a Vue.js application so that it scales and remains maintainable and
             </p>
    </div>
</template>

Footer.vue
<script setup>
</script>
<template>
    <nav>
        <h1>Footer</h1>
    </nav>
</template>

Header.vue
<script setup>
</script>
<template>
    <nav>
        <h1>Header</h1>
    </nav>
</template>
....................................................................................
			 Component Registration
....................................................................................

Global Components

Local Components



Global Components:
  Components are created and registred as part of Application Object
  Global components can be accessed any where the application without explicit configuration.

IN SFC with options object without global registeration
<script>
import ComponentA from './ComponentA.vue'
export default {
  components:ComponentA
}
<script>
<template>
   <ComponentA></ComponentA>
</template>



IN SFC with options object with global registeration
app.component('name',componentDefintion)

<script>
export default {

}
<script>
<template>
   <ComponentA></ComponentA>
</template>

IN SFC with composition api without global registration
<script setup>
import ComponentA from './ComponentA.vue'

<script>
<template>
   <ComponentA></ComponentA>
</template>


IN SFC with composition api with global registration
<script setup>

<script>
<template>
   <ComponentA></ComponentA>
</template>

eg:
 app.component('name',componentDefintion)

interface App {
  component(name: string): Component | undefined
  component(name: string, component: Component): this
}

Global Components are registered in two mode

1.Using options object without build tools

import { createApp } from 'vue'

const app = createApp({})

app.component(
  // the registered name
  'MyComponent',
  // the implementation
  {
    /* ... */
  }
)
2.Using SFC  with build tool

import MyComponent from './App.vue'

app.component('MyComponent', MyComponent)

.................................................................................
			 Local Components Registration
................................................................................

Components are registered when the child component is created

SFC using composition pattern using setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'
</script>

<template>
  <ComponentA />
</template>

SFC using composition pattern using without setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'

export default {
   components: { 
         ComponentsA
   }
}
</script>

<template>
  <ComponentA />
</template>
...................................................................................
			Global Vs Local Component Registration
.................................................................................

=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").
=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.

=>This can affect long-term maintainability similar to using too many global variables.
....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).

This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   <greeter>
Vue supports both cases , but highly recommened is Pascal Case

<script>
//Here we dont need to import and refer in export default.
//Global components can used directly.
//import CompanyVue from '../Company.vue';
export default {
  //  components:Company
}
</script>
<template>
    <nav>
        <company></company>
    </nav>
</template>
.....................................................................................				Exploring Templates
....................................................................................

Templates can be static or dymamic

static templates are having pure html code
dynamic templates are having html + dynamic state

Data Binding:
.............
Types of Binding

1.interpolation
2.property /props
3.attribute binding
4.event binding
5.class and style binding

1.interploation:

 Transfering data from the component(script) to View(template)

SFC:

Using options object Api style

Using Composition Api style



Using options object Api style:
..............................
<script>
// options object
export default {
    //state declaration 
    data() {
        //return object which is called as state object
        return {
            message: 'Hello'
        }
    }
}
</script>
<template>
    <div>
        <h1>Data Binding-Using Options Object</h1>
         <h2>{{message}}</h2>
    </div>
</template>

Using Composition Api:

<script> without setup attribute

<script setup> With setup attribute


<script> without setup attribute:
.................................

The component logic must be encapsulated inside a function called "setup"

export default {

 setup(){

 }

}

eg:
<script>
//composition api with setup function
export default {
    setup() {
        console.log('setup is called')
        const message = 'Hello!!'
        //variables or any thing if you want to access inside template, must be returned via an object
        return {
            //message:message
            message
        }
    }
}
</script>
<template>
    <h1>Data Binding :Using Composition App with Setup Function</h1>
    <h1>{{ message }}</h1>
</template>

<script setup> With setup attribute:
.......................................
<script setup>
//variable declarations
const message = "Hello"
//function declarations
function sayHai() {
    return 'Hai'
}
</script>
<template>
    <h1>Data Binding :Using Composition App with Setup attribute</h1>
    <h1>{{ message }} {{ sayHai() }}</h1>
</template>

Note:

=><script setup> is compile time syntactic sugar for composition API inside SFCs
=>It is highly recommended syntax if you are using both SFCs and compostion API
=>It offers lot benefits over normal syntax

 1.More readable code with less boilerplate
 2.Better Runtime Performance
 3.Render performance
 4.Better IDE support

code segments inside script setup

1.variable declarations
2.function declarations
3.import other components and utiltity functions
....................................................................................

Interpolation:
 What type of data we can interploate

=>primitives - number,string,boolean
=>Objects => literal objects,arrays
<script setup>
//variables
const firstName = 'Subramanian'
const salary = 1000
const status = true
const address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu'
}
const skills = ['Javascript', 'Vue', 'React', 'Java']
const x = 10;
const y = 20;
function multiply() {
    return x * y
}
const foo = undefined;
</script>
<template>
    <div>
        <h1>Data Binding</h1>
        <h2>String</h2>
        <h3>Name : {{ firstName }}</h3>
        <h2>Number</h2>
        <h3>Salary: {{ salary }}</h3>
        <h2>Boolean</h2>
        <h3>Name : {{ status ? 'Available' : 'NotAvaiable' }}</h3>
        <h2>Object</h2>
        <h3>Address : {{ address.city }} {{ address.state }}</h3>
        <h2>Array</h2>
        <h3>Skills : {{ skills }}</h3>
        <h2>Java script Expression</h2>
        <h3>Computation: {{ x + y }} {{ multiply() }}</h3>
        <h2>undefined</h2>
        <h3>Result : {{ foo ? "Found" : "Not Found" }}</h3>


    </div>
</template>
....................................................................................
			Directives Getting Started


Vue is highly modular , code resue is main objective

ways to reuse codes

1.components
2.composables -(hooks)
3.directives


Components are the main building blocks, while composables are focused on reusing stateful logic. Custom directives, on the other hand, are mainly intended for reusing logic that involves low-level DOM access on plain elements.

Directives are used to enchance existing HTML elements with extra behaviour

eg:
  <div id="" class="" style="" ></div>
       |       |       |
      attributes -  Built in attributes

  <div custom-attribute> </div>

Vue helps to add custom attributes on existing elements via "directives" -Attribute Directives

Directive is object, which encapsulate the logic of that attribute

Attribute directives syntax
.............................

v-directiveName

Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak

..................................................................................
			    v-html and v-text
...................................................................................

v-html :
 inserts data into html element as "HTML"
{{}} 
  inserts data into html element as "Plain Text"

				v-text

Update the element's text content. - innerText

<span v-text="msg"></span>
<!-- same as -->
<span>{{msg}}</span>

<script setup>
const firstName = "Subramanian"
</script>
<template>
    <div>
        <h1>Inter polation using mustache Notation</h1>
        <h2>First Name {{ firstName }}</h2>
        <h1>Inter polation using directive - innerHTML</h1>
        <h2 v-html="` First Name ${firstName}`"></h2>
        <h1>Inter polation using directive - innerText</h1>
        <h2 v-text="` First Name ${firstName}`"></h2>
    </div>
</template>
..................................................................................
			       v-bind
.................................................................................

v-bind binds html element attributes or component values(properties) dyamically.

Static binding
 <img src="logo.png"/>

dynamic binding
 if img location is given inside script as variable, now i want to bind that image to img element
<script>
  const imageUrl="logo.png"
</script>

<img v-bind:src="imageUrl"/>
  
<script setup>
const imageUrl = "/src/assets/logo.svg"
</script>
<template>
    <div>
        <h1>Bind Directives</h1>
        <div>
            <h2>Static Image</h2>
            <img src="./assets/logo.svg" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Image using v-bind Directive</h2>
            <img v-bind:src="imageUrl" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Image using v-bind Directive -shortcut</h2>
            <img :src="imageUrl" height="100" width="100" />
        </div>
    </div>
</template>
....................................................................................
			     Data  Representation in Vue
....................................................................................

Data can be reprsented inside component in two ways

1.state pattern
   The data is encasulated inside component itself
2.props pattern
   The data is supplied from outside(parent component)


State Pattern:

 Data is two type

data can be both primitive or objects(arrays)
 
1.Non Reactive 

2.Reactive 

Non Reactive data when you change /update, never tigger render cycles of view

eg:
<script>
export default {
    setup() {
        //state- non reactive
        const counter = 0
        return {
            counter
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
    </div>
</template>

if you want to change data, we need to interact with UI, we need event handling
....................................................................................
				Event Handling
...................................................................................

There are two things in order to write event handling

1.Attach event on dom element
2.Listen on particular event using listeners or handlers

How to attach events and bind listeners , How to write listeners?

Listners are simple javascript function

<script>
export default {
    setup() {
        //state- non reactive
        const counter = 0

        //listener
        function onIncrement() {
            console.log('onIncrement is called')
        }

        return {
            counter, onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
    </div>
</template>

....

How to bind events?

 There is a directive called "v-on:nameOftheEvent" directive
 v-on:click="handler"
 We have even short cut
 @click="handler"

<script>
export default {
    setup() {
        //state- non reactive
        const counter = 0

        //listener
        function onIncrement() {
            console.log('onIncrement is called')
        }

        return {
            counter, onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>

    </div>
</template>
.....................................................................................
                           State Mutation -  change/update
....................................................................................

<script>
export default {
    setup() {
        //state- non reactive
        let counter = 0

        //listener
        function onIncrement() {
            console.log('onIncrement is called')
            //update the state
            counter++
            console.log(`Counter ${counter}`)

        }

        return {
            counter, onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>

    </div>
</template>

Here we are trying to update the counter state variable, there is update happening but it does not trigger "view update"
   Because the state is non reactive...
...................................................................................
				Reactivity
...................................................................................


What is Reactivity?

Reactivity is one of the core vue js concept.
Component state are reactive javascript objects.

When we modify them, the view updates.

Reactivity is a programming style that allows us to adjust to changes in declartive manner.

eg:
Excel spreed sheet is one of the best eg for reactivitity programming

eg;

let A1=1
let A2=2
let A3 =A1+A2
console.log(A3) => 3

A2=4

console.log(A3) 

Here when you mutate A1 or A2, does not change automatically.

How to implement to trigger this changes in js?

We can wrap this code inside function

 let A3
 function update(){
   A3 = A1 + A2
 }

in order get fresh value, we have to re-run the code that updates A3

Pointers:

1.There should be some update function, which produces a "side effect /effect".
  if any function which changes the state of the program called side effect.

2.Here ,A1 and A2 are considered dependencies of the side effect, because which helps makes side effects.
  According to dependencies, this effect is said to be "subscriber"

When ever "A1 and A2" changed, we need to invoke "update" function,which cause side effects.

It looks like event driven programming (Pub-Sub Pattern /Observerable and Observer) 

 function whenDepChange(update){
     update()
 }

 let A3
 function update(){
   A3 = A1 + A2
 }

 whenDepChange(function(){
     A3 = A1 + A2
 })
 whenDepChange(update)

Role of whenDepchange function:
................................

1.Tracking the dependencies,
    By evaulating the expression A1 and A2 ,Whether any one of them is read or not.

Tracker--->triggers--whenDepChange--->runs update function---returns modified state

....................................................................................
			   How vue implements Reactivity
.....................................................................................

There are two patterns have implmented in order to implement reactivity

1.Getters and Setters of Object to be changed 
   Vue 2 has implmented this pattern
  Still this pattern is available in V3 as well

2.Javascript Proxy pattern
   Vue 3 has implemented Proxy for Reactivity.


When we use SFC using Compostion Api pattern
  reactivity implementations are given as apis

When we use SFC using Options Api Pattern
  reactivity implementations are given inside "data" method 
 Options api uses only "Getters and Setters" Pattern
  

Compostion Api pattern:

ref()
computed()
reactive()
readonly()
watchEffect()
watchPostEffect()
watchSyncEffect()
watch()

How to represent reactive State?

ref api
 Used for primitives -strings,numbers,booleans
 objects can be used but avoid.
reactive api
 Used for objects and arrays.


eg:
<script>
//imort reactive apis
import { ref } from 'vue'

export default {
    setup() {
        //reactive state
        let counter = ref(0)
        console.log(counter.value)

        //listener
        function onIncrement() {
            console.log('onIncrement is called')
            //update the state
            counter.value++
            console.log(`Counter ${counter.value}`)
        }

        return {
            counter, onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>

    </div>
</template>

Reactivity with script setup attribute
<script setup>
//imort reactive apis
import { ref } from 'vue'

//reactive state
let counter = ref(0)
//listener
const onIncrement = () => counter.value++
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>
    </div>
</template>

..................................................................................
			State Mutation using Options Api
...................................................................................

<script>
export default {
    data() {
        //reactive state
        return {
            counter: 0
        }
    },
    //listeners
    methods: {
        onIncrement() {
            this.counter++
        }
    }

}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>
    </div>
</template>
....................................................................................
			Mulitiple Listeners and State mutation
....................................................................................
<script setup>
import { ref } from 'vue';
const counter = ref(0)

//two listeners
const onIncrement = () => counter.value++
const onDecrement = () => counter.value--

</script>
<template>
    <div>
        <h1>Counter Application</h1>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>
    </div>
</template>
<style>
</style>
....................................................................................
			 Multiple Reactive State Variables
<script setup>
import { ref } from 'vue';

//reactive states
const like = ref(0)
const dislike = ref(0)

//two listeners
const onLike = () => like.value++
const onDislike = () => dislike.value++

</script>
<template>
    <div>
        <h1>Like and DisLike Application</h1>
        <h1>Likes {{ like }} DisLike {{ dislike }}</h1>
        <button @click="onLike">Like</button>
        <button @click="onDislike">Dislike</button>
    </div>
</template>
<style>
</style>
...................................................................................
			 How to declare objects

<script setup>
import { reactive } from 'vue';

//reactive object
const counter = reactive({
    count: 0
})
console.log(counter.count)
const onIncrement = () => counter.count++

</script>
<template>
    <div>
        <h1>Counter Application</h1>
        <h1>Counter {{ counter.count }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>
<style>
</style>
.................................................................................
			 Reactivity for Object and its nested Object

In vue, state is deeply reactive by default, This means you can change inner objects 
which is reactive.

<script setup>
import { reactive } from 'vue';

//reactive  deep nested objects
const app = reactive({
    counter: {
        inc: {
            count: 0
        }
    }
})
const onIncrement = () => app.counter.inc.count++

</script>
<template>
    <div>
        <h1>Counter Application</h1>
        <h1>Counter {{ app.counter.inc.count }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>
<style>
</style>
.....................................................................................
			Arrays Rendering- List Rendering
....................................................................................

Arrays:
=>Arrays are basic datastructure which is used to render collection of data.
=>Arrays are dynamic 

Arrays and UI
 if you want to render more data , then array is used..
Arrays can help to build in UI layouts in various ways

Layouts:

1.List View
  <ul><li></li></ul>

2.Card View layout
   <div> <header>....

3.Grid View layout
   <table>

How to iterate array inside template?
 
 We have special directive called "v-for"
 <script setup>
import { reactive } from 'vue';
import TODOS from './mock-data/todos';

const todos = reactive(TODOS)

</script>
<template>
    <div>
        <h1>Todo List</h1>
        <ul>
            <li v-for="todo in todos">
                <span>{{ todo.id }} {{ todo.title }}</span>
            </li>
        </ul>
    </div>
</template>
...................................................................................
			List with Index
...................................................................................


<script setup>
import { reactive } from 'vue';

const list = reactive([
    {
        id: 1,
        name: 'A'
    },
    {
        id: 2,
        name: 'B'
    },
    {
        id: 3,
        name: 'A'
    }
])
</script>
<template>
    <div>
        <h1>List- with Index</h1>
        <ul>
            <li v-for="(item, index) in list">
                <span>{{index}} - {{ item }}</span>
            </li>
        </ul>
    </div>
</template>
.................................................................................
				key

if there is reordering in the list when we do some changes like sorting,filtering
vue uses an algorthim called patch..
We can tell to that algorthim how we can re arrange. thats where key attribute comes into picture.
key value must be unquire

<script setup>
import { reactive } from 'vue';
import TODOS from './mock-data/todos';

const todos = reactive(TODOS)

</script>
<template>
    <div>
        <h1>Todo List</h1>
        <ul>
            <li v-for="todo in todos " :key="todo.id">
                <span>{{ todo.id }} {{ todo.title }}</span>
            </li>
        </ul>
    </div>
</template>
....................................................................................
			 Nested List(nested Array)


<script setup>
import { reactive } from 'vue';

const persons = [
    {
        id: 1,
        name: 'A',
        friends: [
            {
                name: 'F1'
            },
            {
                name: 'F2'
            },
            {
                name: 'F3'
            }
        ]
    },
    {
        id: 2,
        name: 'A1',
        friends: [
            {
                name: 'B1'
            },
            {
                name: 'B2'
            },
            {
                name: 'B3'
            }
        ]
    },
    {
        id: 3,
        name: 'A2',
        friends: [
            {
                name: 'C1'
            },
            {
                name: 'C2'
            },
            {
                name: 'C3'
            }
        ]
    }
]
const list = reactive(persons)
</script>
<template>
    <ul>
        <li v-for="person in list">
            <span>{{ person.id }} {{ person.name }}</span>
            <ul>
                <li v-for="friend of person.friends">
                    <span>{{ friend.name }}</span>
                </li>
            </ul>
        </li>
    </ul>


</template>
.....................................................................................				 Object as iterable
......................................................................................
<script setup>
import { reactive } from 'vue';

const movie = reactive({
    title: 'The Matrix',
    langague: ['English', 'Spanish', 'Hindi', 'Tamil', 'Telgu'],
    hours: '2 hrs 5 mins'
})

</script>
<template>
    <ul>
        <li v-for="tmpMovie in movie">
            <span>{{tmpMovie}}</span>
        </li>
    </ul>

</template>
.....................................................................................
		 Range - If you want to repeat something n of times
....................................................................................
<script setup>
import { ref } from 'vue';

const start = ref(1)
</script>
<template>
    <ul>
        <li v-for="start in 100">
            <span>{{ start }}</span>
        </li>
    </ul>

</template>
..................................................................................
			Template and v-for
.................................................................................
<script setup>
import { reactive } from 'vue';
import todos from './mock-data/todos';

const TODOS = reactive(todos)
</script>
<template>
    <template v-for=" todo in todos">
        <h1>Todo Id {{ todo.id }}</h1>
        <p>Status {{ todo.completed ? 'Completed' : 'Not Completed' }}</p>
    </template>

</template>
....................................................................................
		   We can repeat Components
....................................................................................

<Item v-for="n in 10"></Item>

<script setup>
import { ref } from 'vue';
import Greeter from './components/greeter/Greeter.vue';

const start = ref(1)
</script>
<template>
    <Greeter v-for="start in 5"></Greeter>
</template>
.....................................................................................
			 Array Mutations
.....................................................................................
<script setup>
import { reactive } from 'vue';

const todos = reactive([])
const addItem = () => {
    //array mutation - add element into array
    todos.push({
        id: Math.random(),
        text: 'do this '
    })
}
</script>
<template>
    <ul>
        <li v-for="todo in todos">
            {{ todo }}
        </li>
    </ul>
    <button @click="addItem">Add New Item</button>
</template>

In Array all apis will not trigger render cycle.

Apis which trigger render cycle; -Mutating apis

1.push
2.pop
3.shift
4.unshift
5.splice
6.sort
7.reverse

.....................................................................................
			Filtering/sorting arrays with Immutable api
<script setup>
import { ref } from 'vue';
import TODOS from './mock-data/todos';

const todos = ref(TODOS)

const filter = () => todos.value = todos.value.filter(todo => todo.completed)

</script>
<template>
    <button @click="filter">filter</button>

    <ul>
        <li v-for="todo in todos">
            {{ todo }}
        </li>
    </ul>

</template>

..................................................................................
			Object destructuring and state Mutation
.................................................................................. 

<script setup>
import { reactive } from 'vue';

// const location = reactive({
//     lat: 10.5,
//     lng: 90.5
// })
const { lat, lng } = reactive({
    lat: 10.5,
    lng: 90.5
})

const updateLocation = ()=>{
    lat = 22
}
</script>
<template>
    <div>
        <!-- <p>Lat {{ location.lat }}</p>
        <p>Lng {{ location.lng }}</p> -->
         <p>Lat {{ lat }}</p>
        <p>Lng {{ lng }}</p>
        <button @click="updateLocation">Update Location</button>
    </div>
</template>

here reactive will not trigger for after destructure

toRef
toRefs

const location = reactive({
    lat: 10.5,
    lng: 90.5
})

let { lat, lng } = toRefs(location)

let { lat, lng }  = toRefs(reactive({
    lat: 10.5,
    lng: 90.5
}))
or
..

<script setup>
import { reactive,toRefs } from 'vue';

const location = reactive({
    lat: 10.5,
    lng: 90.5
})
let { lat, lng } = toRefs(location)

const updateLocation = () => {
    lat.value = 22
}
</script>
<template>
    <div>
        <p>Lat {{ lat }}</p>
        <p>Lng {{ lng }}</p>
        <button @click="updateLocation">Update Location</button>
    </div>
</template>
...................................................................................
			  Computed Properties
...................................................................................

<script setup>
const products = [
    {
        id: 1,
        name: 'books',
        items: [
            "Vue in Action",
            "Vue Master Class"
        ]
    },
    {
        id: 2,
        name: 'electronics',
        items: []
    },
    {
        id: 3,
        name: 'food',
        items: [
            "Rice"
        ]
    },
    {
        id: 4,
        name: 'building material',
        items: []
    }
]
</script>
<template>
    <ul>
        <li v-for="product in products">
            <span>Id {{ product.id }} Name {{ product.name }} Stock {{ product.items.length > 0 ? 'In Stock' : 'OutOfStock' }}
            </span>
        </li>
    </ul>
</template>

Here we have written "expression inside template", which is not recommended 

=>The code is not declarative (dont write any js logic)
=>The code is not maintainable , later if you want to change any display message.

We have to isloate the template expression logic into a separate method called as 
"computed property"

Computed property is written using "computed" api.

<script setup>
import { computed, reactive } from 'vue';

const products = reactive({
    id: 1,
    name: 'books',
    items: [
        "Vue in Action",
        "Vue Master Class"
    ]
})

const stockInfo = computed(() => {
    return products.items.length > 0 ? 'InStock' : 'OutofStock'
})
</script>
<template>
    <div>
        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ products.items.length > 0 ? 'InStock' :
                'OutofStock'
        }}</h3>

        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ stockInfo }}</h3>
    </div>
</template>
.................................................................................
			Template logic in Regular methods

<script setup>
import { computed, reactive } from 'vue';

const products = reactive({
    id: 1,
    name: 'books',
    items: [
        "Vue in Action",
        "Vue Master Class"
    ]
})

const update = () => products.items.push("Demo")

const update1 = () => {
    products.id = 2
}

const stockInfo = computed(() => {
    console.log('computed is called')
    return products.items.length > 0 ? 'InStock' : 'OutofStock'
})
//regular /normal javascript method
const stockInfoRegular = () => {
    console.log('regular method is called')
    return products.items.length > 0 ? 'InStock' : 'OutofStock'
}

</script>
<template>
    <div>
        <h1>Javascript Expression inside Template</h1>
        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ products.items.length > 0 ? 'InStock' :
                'OutofStock'
        }}</h3>

        <h1>Javascript Expression as ComputedProperty</h1>

        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ stockInfo }}</h3>

        <h1>Javascript Expression as Regular Method</h1>

        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ stockInfoRegular() }}</h3>

        <button @click="update">Render1</button>
        <button @click="update1">Render2</button>

    </div>
</template>

computed vs regular methods:
............................

computed is cached where regular methods is not cached.

computed is lazy , that means when ever the property is changed which is represented
inside computed method

computed method is called only reactive dependency.

computed method is always "getter method"
.....................................................................................
<script setup>
import { computed, ref } from 'vue';
const firstName = ref('Subramanian')
const lastName = ref('Murugan')

const fullName = computed(() => {
    return `${firstName.value} ${lastName.value}`
})

</script>
<template>
    <h1>Name {{ fullName }}</h1>
</template>
....................................................................................
			   Watchers
...................................................................................

Computed properties allow us to declaratively compute derived values. However, there are cases where we need to perform "side effects" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation

<script setup>
import { ref, watch } from 'vue';
const x = ref(0)

//watcher
watch(x, (newX) => {
    console.log(` X value is ${newX}`)
})

</script>
<template>
    <button @click="x++">+</button>
</template>
....................................................................................
			 Watch Multiple Properties
....................................................................................
<script setup>
import { ref, watch } from 'vue';
const x = ref(0)
const y = ref(0)
const z = ref(0)
//watch multiple sources
watch([x, y, z], ([tempX, tempY, tempZ]) => {
    console.log(`X ${tempX} Y ${tempY} Z ${tempZ}`)
})

</script>
<template>
    <button @click="x++">X</button>
    <button @click="y++">Y</button>

</template>
....................................................................................
			 How to watch literal object properties

<script setup>
import { reactive, ref, watch } from 'vue';

const counter = reactive({
    up: 0,
    down: 100
})
const increment = () => counter.up++
const decrement = () => counter.down--


//watch object particular property
watch(() => counter.up, count => {
    console.log(`Counter Inside Watch ${count}`)
    if (count > 10) {
        alert(' Volum is High')
    }
})

</script>
<template>
    <h1>Up : {{ counter.up }}</h1>
    <button @click="increment">+</button>
    <h1>Down : {{ counter.down }}</h1>
    <button @click="decrement">-</button>
</template>
...................................................................................
				Deep watching
..................................................................................
if you watch the whole reactive object , it will create a deep watcher, the callback will triggered if any property the object changes


<script setup>
import { reactive, ref, watch } from 'vue';

const counter = reactive({
    up: 0,
    down: 100
})
const x = ref(0);

const increment = () => counter.up++
const decrement = () => counter.down--


//watch  whole reactive object
//1st param is reactive object to be watched
//2nd param is reactive to be returned
//3rd param is only if there is different object
watch(counter, () => {
    console.log('watching...')
    return counter
}, (newValue, OldValue) => {
    //immutable 
    console.log(newValue, OldValue)
    return counter
}, { deep: true })


</script>
<template>
    <h1>Up : {{ counter.up }}</h1>
    <button @click="increment">+</button>
    <h1>Down : {{ counter.down }}</h1>
    <button @click="decrement">-</button>

    <button @click="x++">{{ x }}</button>

</template>
....................................................................................
			 watchEffect
.....................................................................................

watch is lazy, means called only if given state changes, watchEffect is executed atleast onece, and reexecuted whenever the property changes.

<script setup>
import { ref, watch, watchEffect } from 'vue'

// bind ref as a variable
let count = ref(0)

// watch(count, () => {
//     console.log(count.value)
// })
watchEffect(() => {
    console.log(count.value)
})

</script>
<template>
    <p>{{ count }}</p>
    <button @click="count++">+</button>
</template>
...................................................................................
			 Conditional Rendering -
..................................................................................


v-if and v-else:
................

<script setup>
import { computed, ref } from 'vue'
const name = ref('admin')

const isAdmin = computed(() => name.value === 'admin')

</script>
<template>
    <div>
        <!-- <h1 v-if="name === 'admin'">You are Admin</h1>
        <h1 v-else>You are guest</h1> -->
        <h1 v-if="isAdmin">You are Admin</h1>
        <h1 v-else>You are guest</h1>
    </div>
</template>

v-if takes boolean expression or truthy or falsy value, if it is true that block will be executed else, v-else block will be executed
v-if and v-else should be in the same place.















































