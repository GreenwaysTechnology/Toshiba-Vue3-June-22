			   Vue-js
....................................................................................

What is Vue?
 Vue is java script framework for building User interface apps on the client(browser)
 Vue takes responsiblity of changing html page on fly.DOM Programming.

HTML:
What is HTML?

How HTML is represented inside browser?

What angular/react/vue is doing with HTML?

If you look at any web technology, either server side or client side.
  HTML is common

Server side technologies like JEE(Servlet),ASP.net,PHP , Create HTML Pages on fly -dynamic web page.

Client side technologies like javascript , Processing rendered html(accessing html elements),
javascript can be used to create "HTML pages on fly" like server side technologies.
............................................................................................
				Internals of HTML Representation
..........................................................................................

HTML is programming language -  DSL pl /declarative pl.

index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
-------------------Browser
loader---LOAD Code into browser
 |
   from file: or http:
 |
Parser : Parser is special compiler which converts source into lexcial tree(string tree)
 |
body
  div
     h1
        Welcome 
     h1
  div
body
|
 Complier-Compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body
..............................................................................................
				Runtime  -  Allocate Memory for HTML
...........................................................................................				
HTML Execution engine : Request Os ,to allocate memory :Runtime

-LinkedList - c

body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body

-Nodes are connected each other in hierachical structure(tree)
 
Linking the Nodes: Tree

body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
body
 |
 |
Layout/Paint Engine: will convert nodes into pxs : final output
.............................................................................................
				 Birth of Java Script
.............................................................................................

..............................................................................................
				Dynamic HTML - Inside Web Browser
.............................................................................................

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?
  
One spec was published ,As per that spec
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be reprsented as Objects" : Object oriented Document Programming.
..............................................................................................
				Birth of Frameworks and libs



............................................................................................
How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                 Every Html ELEMENT Inside Browser is "C Program"

	       Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.	*******************************************************************************************	
.............................................................................................
				DOM Programming
.............................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.. 2008(Angular js) 2013(react)...

Popular DOM frameworks/lib:
1.React
2.Angular
3.Vue.js
.....................................................................................
                           Types of Javascript apps(IN UI)
			    (Styles of DOM Programming)
				   (Vue)
.....................................................................................

1.Standalone Script

Vue can be used as a standalone script file - no build step required! If you have a backend framework already rendering most of the HTML, or your frontend logic isn't complex enough to justify a build step, this is the easiest way to integrate Vue into your stack. You can think of Vue as a more declarative replacement of jQuery in such cases


=>It is old model of writing code.
=>server always creates html pages , sends html to browser
=>Client side we need to submit forms
   we need to validate the forms-js can be used.
   some animations 
   if you want to submit forms to the server for processing some data
   (ajax)

Technologies:
  jQuery


2.Single-Page Application (SPA):
Some applications require rich interactivity and non-trivial stateful logic on the frontend. The best way to build such applications is to use an architecture where Vue not only controls the entire page, but also handles data updates and navigation without having to reload the page. This type of application is typically referred to as a Single-Page Application (SPA).

SPAs typically require the backend to expose API endpoints - but you can also pair Vue with solutions like Inertia.js to get the SPA benefits while retaining a server-centric development model.

Fullstack / SSR

Pure client-side SPAs are problematic when the app is sensitive to SEO and time-to-content. This is because the browser will receive a largely empty HTML page, and has to wait until the JavaScript is loaded before rendering anything.

Vue provides first-class APIs to "render" a Vue app into HTML strings on the server. This allows the server to send back already-rendered HTML, allowing end users to see the content immediately while the JavaScript is being downloaded. Vue will then "hydrate" the application on the client side to make it interactive. This is called Server-Side Rendering (SSR) and it greatly improves Core Web Vital metrics such as Largest Contentful Paint (LCP).

There are higher-level Vue-based frameworks built on top of this paradigm, such as Nuxt, which allow you to develop a fullstack application using Vue and JavaScript.


JAMStack / SSG#
Server-side rendering can be done ahead of time if the required data is static. This means we can pre-render an entire application into HTML and serve them as static files. This improves site performance and makes deployment a lot simpler since we no longer need to dynamically render pages on each request. Vue can still hydrate such applications to provide rich interactivity on the client. This technique is commonly referred to as Static-Site Generation (SSG), also known as JAMStack.

The Vue team maintains a static-site generator called VitePress, which powers this website you are reading right now! In addition, Nuxt also supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.


Beyond the Web:
...............

Although Vue is primarily designed for building web applications, it is by no means limited to just the browser. You can:

Build desktop apps with Electron or Tauri
Build mobile apps with Ionic Vue
Build desktop and mobile apps from the same codebase with Quasar
Use Vue's Custom Renderer API to build custom renderers targeting WebGL or even the terminal!

App selections:

Whether your app is legacy server side apps built using j2ee or .net,php,rails--->
 Standalone vue.js

Your app is api centeric(webservices)/microservices

Vue can be used as "SPA"

SPA With SSR for better optimization and SEO ready

SPA and SSR With SSG/JAM Stack - where your app is having static data

Getting started with Vue:
........................

Project Setup:
..............

1.without build tools

2.with build tools


1.without build tools

Steps:

1.create Project

>mkdir vue-legacy

vue-legacy>mkdir src

create index.html outside src dir

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
</head>
<body>
    
</body>
</html>

in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build


Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.


Prod Build
 <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
    <!-- This is dev build -->
    <script src="https://unpkg.com/vue@3"></script>
    <!-- This is production build -->
    <!-- <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script> -->
</head>
<body>
   
</body>

</html>
....................................................................................
				Vue Application
....................................................................................

Vue is just javascript framework, offers apis,infrastructure to build "DOM" programming.

DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.


Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

   <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('create Element')
            const Heading = document.createElement('h1')
            Heading.innerHTML = 'Hello DOM!'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement();
    </script>

2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates

Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
			   java script => binds the state(data)


How Vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue Organizes the UI into Smaller and Small UI
=>Vue Breaks complex UI into Smaller UI
   This model is called Composition

Why Composition?
=>The UI can be reused any where in the app.
=>The code maintaince is very easy,because it is independant.

           This arch is called as "component driven arch"

What is component?
   Component is object

Any Object has three things

1.state - data associated with object
2.behaviour - methods are associated with object, which updates the state.
3.identity -  every object is unquie

Component has even extra features
1.User interface
   Object has visibility.

Component is term introduced by MicroSoft early 90s, in order to differentiate UI elments from back end objects.
.....................................................................................
			    Components
.....................................................................................
Vue is component driven framework, in vue , we have to create components.

Before creating components, we need to have "VUE runtime".

Vue Runtime is added or bootstraped as soon as we add script having vue.js framework 


Steps:

1.create Application Object

Pro Vue 3.
var app = new Vue({   })
    
Vue 3:

1.1.Get Vue Instance

We can get Vue Instance 

A.Via Global Vue variable
B.Via ES 6 modules

....................................................................................
			A.Via Global Vue variable
...................................................................................

Vue is Root Instance having lot methods (factory methods)

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 

etc..

1.2. call method called createApp

Creates an application instance.

function createApp(rootComponent: Component, rootProps?: object): App

const app = createApp()

console.log(app)

Application Object methods:
............................

component: ƒ component(name, component)
config: (...)
directive: ƒ directive(name, directive)
mixin: ƒ mixin(mixin)
mount: (containerOrSelector) => {…}
provide: ƒ provide(key, value)
unmount: ƒ unmount()
use: ƒ use(plugin, ...options)
version: "3.2.36"
_component: {}
_container: null
_context: {app: {…}, config: {…}, mixins: Array(0), components: {…}, directives: {…}, …}
_instance: null
_props: null
_uid: 0


       //way -1
        //     //get Vue Instance
        //  const vue  = Vue
        // // console.log(vue)
        // const app = vue.createApp()
        // console.log(app)
        //way -2
        // const app = Vue.createApp()
        // console.log(app)
        //way - 3 : es 6 destructuring syntax
        const { createApp } = Vue
        const app = createApp()
        console.log(app)
.....................................................................................
				B.Via ES 6 modules
....................................................................................

Scripts should imported using "importmap" of script tag

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E6 Modules-without Build tools</title>
    <!-- Poly file for import maps -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
</head>

<body>
    <div id="app">

    </div>
    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
    <script type="module">
        import { createApp } from 'vue'
        const app = createApp()
        console.log(app)
    </script>

</body>

</html>


Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.

    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>

Not for production

The import-maps-based setup is meant for learning only - if you intend to use Vue without build tools in production, make sure to check out the Production Deployment Guide.
....................................................................................
			 Root Component
....................................................................................

Component is object represented as literal object.

const rootComponent = {

}

What component contains:
Component information can be categoriezied into various segments

UI/Rendering

1.template
2.render
3.compilerOptions 


State:

1.data
2.props
3.computed
4.methods
5.watch
6.emits
7.expose

LifeCycles
............
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered
activated
deactivated
serverPrefetch

Composition

1.provide
2.inject
3.mixins
4.extends

Misc

name
inheritAttrs
components
directives

Component Instance

$data
$props
$el
$options
$parent
$root
$slots
$refs
$attrs
$watch()
$emit()
$forceUpdate()
$nextTick()
....................................................................................

Template:
 => It is html along with some special instructions
 => It is compiled into sequence of java script methods by vue compilers
 => Every component will have template
 => root component uses container element as template

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Root Component</title>
  <!-- Poly file for import maps -->
  <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
  <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
</head>

<body>
  <div id="app">

  </div>

  <script type="module">
    import { createApp } from 'vue'

    const rootComponent = {
      template: `
             <h1>Welcome to Vue App</h1>
             <p>How are you?</p>
      `
    }
    const app = createApp(rootComponent)

    //rendering root Component on existing dom tree
    app.mount('#app')
  </script>

</body>

</html>
...................................................................................
			  How to write modular code

1.you have to write application componet in a separate folders and files

src
 |
 components
    |
    App.js
index.html

src/App.js
export default {
    template: `
        <div>
             <h1>Vue App</h1>
        </div>
    `
}
index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Root Component</title>
    <!-- Poly file for import maps -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
</head>

<body>
    <div id="app">

    </div>

    <script type="module">
        import { createApp } from 'vue'
        import App from './src/App.js'
        createApp(App).mount('#app')
    </script>

</body>

</html>

.....................................................................................
			How to setup vue Apps using Build Tools
.....................................................................................

Tool for creating and Managining vue app life cycles


vue-cli
 old pattern
vite
 modern pattern - recommended
 npm init vue@latest

This is abstraction for vite based project templates

>npm init vue@latest
Need to install the following packages:
  create-vue@latest
Ok to proceed? (y) y

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-modern
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add Cypress for both Unit and End-to-End testing? ... No / Yes
√ Add ESLint for code quality? ... No / Yes
√ Add Prettier for code formatting? ... No / Yes

Scaffolding project in E:\session\Toshiba\vue-session\vue-modern...

Done. Now run:

  cd vue-modern
  npm install
  npm run lint
  npm run dev
....................................................................................
				Component Creational Pattern
....................................................................................

1.Plain Java script Pattern

App.js
export default {
  
  ...options 
  
}

2.Single File Components -SFC

 It is more declarative way of creating components
 As name suggest, All Component logic inside single file.

Component has three major sections

1.template
2.javascript
3.style

In SFC Pattern, we isloate very clearly into three sections

<script>
   ....All javascript code
</script>
<template>
  ...template code
</template>
<style>
 //style for this component
</style>


Plain javascript pattern is usefull where there is no build workflow,SFC is usefull and necessary in build tool work flow 

SFC components are saved with fileName.vue
....................................................................................
                                SFC API styles
...................................................................................

				SFC Component
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api



Commonality between both patterns

1.code segementation is same
  <script></script>
  <template></template>
  <style></style>


Options Api Style Pattern:
<!-- Options Api Pattern -->
<script>
//you have to return options object
export default {

}
</script>
<template>
  <h1>Welcome to Vue App-Using SFC On Options Object Pattern</h1>
</template>
<style>
</style>


Compostion Api Pattern:
<!-- Compostion api Pattern  -->
<script setup>
 //java script code can go directly
 
</script>
<template>
  <h1>Single File Component using Composition Api Pattern</h1>
</template>
<style>
</style>
.....................................................................................
				Component Composition


Single File Component(SFC)
.........................

SFC can be written in two styles

1.Using options api

2.Using Composition api


App.vue
<script>
import Greeter from "./components/Greeter.vue";
export default {
    components: { Greeter }
}
</script>
<template>
   <h1>Vue Application</h1>
   <Greeter></Greeter>
</template>

Greeter.vue
<script>
</script>
<template>
    <h1>Greeter</h1>
</template>

Welcome.vue
<script>
</script>
<template>
    <h1>Welcome</h1>
</template>

What if i want to visualize the tree model created by vue?

Dev tools: Vue dev tool
https://devtools.vuejs.org/

.................................................................................
			   Project layout

In general Projects can be categorized into  2 sections

1.feature based
products
customers
inventory
payment
etc...
2.framework based
src/
 components
    ....
Feature + framework
 
 components
    |
    features

components
  |
  products
    products-list.vue
    products-edit.vue
    products-search.vue

eg:

src/App.vue
<script setup>
import Header from './components/layouts/Header.vue';
import Footer from './components/layouts/Footer.vue';
import Body from './components/layouts/Body.vue';
</script>
<template>
    <div>
        <Header></Header>
        <Body></Body>
        <Footer></Footer>
    </div>
</template>

src/components/layout

Body.vue
<script setup>
import Greeter from '../greeter/Greeter.vue';
</script>
<template>
    <div>
        <Greeter></Greeter>
        <p>
            What is the best way to structure a Vue.js application so that it scales and remains maintainable and
             </p>
    </div>
</template>

Footer.vue
<script setup>
</script>
<template>
    <nav>
        <h1>Footer</h1>
    </nav>
</template>

Header.vue
<script setup>
</script>
<template>
    <nav>
        <h1>Header</h1>
    </nav>
</template>
....................................................................................
			 Component Registration
....................................................................................

Global Components

Local Components



Global Components:
  Components are created and registred as part of Application Object
  Global components can be accessed any where the application without explicit configuration.

IN SFC with options object without global registeration
<script>
import ComponentA from './ComponentA.vue'
export default {
  components:ComponentA
}
<script>
<template>
   <ComponentA></ComponentA>
</template>



IN SFC with options object with global registeration
app.component('name',componentDefintion)

<script>
export default {

}
<script>
<template>
   <ComponentA></ComponentA>
</template>

IN SFC with composition api without global registration
<script setup>
import ComponentA from './ComponentA.vue'

<script>
<template>
   <ComponentA></ComponentA>
</template>


IN SFC with composition api with global registration
<script setup>

<script>
<template>
   <ComponentA></ComponentA>
</template>

eg:
 app.component('name',componentDefintion)

interface App {
  component(name: string): Component | undefined
  component(name: string, component: Component): this
}

Global Components are registered in two mode

1.Using options object without build tools

import { createApp } from 'vue'

const app = createApp({})

app.component(
  // the registered name
  'MyComponent',
  // the implementation
  {
    /* ... */
  }
)
2.Using SFC  with build tool

import MyComponent from './App.vue'

app.component('MyComponent', MyComponent)

.................................................................................
			 Local Components Registration
................................................................................

Components are registered when the child component is created

SFC using composition pattern using setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'
</script>

<template>
  <ComponentA />
</template>

SFC using composition pattern using without setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'

export default {
   components: { 
         ComponentsA
   }
}
</script>

<template>
  <ComponentA />
</template>
...................................................................................
			Global Vs Local Component Registration
.................................................................................

=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").
=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.

=>This can affect long-term maintainability similar to using too many global variables.
....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).

This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   <greeter>
Vue supports both cases , but highly recommened is Pascal Case

<script>
//Here we dont need to import and refer in export default.
//Global components can used directly.
//import CompanyVue from '../Company.vue';
export default {
  //  components:Company
}
</script>
<template>
    <nav>
        <company></company>
    </nav>
</template>
.....................................................................................				Exploring Templates
....................................................................................

Templates can be static or dymamic

static templates are having pure html code
dynamic templates are having html + dynamic state

Data Binding:
.............
Types of Binding

1.interpolation
2.property /props
3.attribute binding
4.event binding
5.class and style binding

1.interploation:

 Transfering data from the component(script) to View(template)

SFC:

Using options object Api style

Using Composition Api style



Using options object Api style:
..............................
<script>
// options object
export default {
    //state declaration 
    data() {
        //return object which is called as state object
        return {
            message: 'Hello'
        }
    }
}
</script>
<template>
    <div>
        <h1>Data Binding-Using Options Object</h1>
         <h2>{{message}}</h2>
    </div>
</template>

Using Composition Api:

<script> without setup attribute

<script setup> With setup attribute


<script> without setup attribute:
.................................

The component logic must be encapsulated inside a function called "setup"

export default {

 setup(){

 }

}

eg:
<script>
//composition api with setup function
export default {
    setup() {
        console.log('setup is called')
        const message = 'Hello!!'
        //variables or any thing if you want to access inside template, must be returned via an object
        return {
            //message:message
            message
        }
    }
}
</script>
<template>
    <h1>Data Binding :Using Composition App with Setup Function</h1>
    <h1>{{ message }}</h1>
</template>

<script setup> With setup attribute:
.......................................
<script setup>
//variable declarations
const message = "Hello"
//function declarations
function sayHai() {
    return 'Hai'
}
</script>
<template>
    <h1>Data Binding :Using Composition App with Setup attribute</h1>
    <h1>{{ message }} {{ sayHai() }}</h1>
</template>

Note:

=><script setup> is compile time syntactic sugar for composition API inside SFCs
=>It is highly recommended syntax if you are using both SFCs and compostion API
=>It offers lot benefits over normal syntax

 1.More readable code with less boilerplate
 2.Better Runtime Performance
 3.Render performance
 4.Better IDE support

code segments inside script setup

1.variable declarations
2.function declarations
3.import other components and utiltity functions
....................................................................................

Interpolation:
 What type of data we can interploate

=>primitives - number,string,boolean
=>Objects => literal objects,arrays
<script setup>
//variables
const firstName = 'Subramanian'
const salary = 1000
const status = true
const address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu'
}
const skills = ['Javascript', 'Vue', 'React', 'Java']
const x = 10;
const y = 20;
function multiply() {
    return x * y
}
const foo = undefined;
</script>
<template>
    <div>
        <h1>Data Binding</h1>
        <h2>String</h2>
        <h3>Name : {{ firstName }}</h3>
        <h2>Number</h2>
        <h3>Salary: {{ salary }}</h3>
        <h2>Boolean</h2>
        <h3>Name : {{ status ? 'Available' : 'NotAvaiable' }}</h3>
        <h2>Object</h2>
        <h3>Address : {{ address.city }} {{ address.state }}</h3>
        <h2>Array</h2>
        <h3>Skills : {{ skills }}</h3>
        <h2>Java script Expression</h2>
        <h3>Computation: {{ x + y }} {{ multiply() }}</h3>
        <h2>undefined</h2>
        <h3>Result : {{ foo ? "Found" : "Not Found" }}</h3>


    </div>
</template>
....................................................................................
			Directives Getting Started


Vue is highly modular , code resue is main objective

ways to reuse codes

1.components
2.composables -(hooks)
3.directives


Components are the main building blocks, while composables are focused on reusing stateful logic. Custom directives, on the other hand, are mainly intended for reusing logic that involves low-level DOM access on plain elements.

Directives are used to enchance existing HTML elements with extra behaviour

eg:
  <div id="" class="" style="" ></div>
       |       |       |
      attributes -  Built in attributes

  <div custom-attribute> </div>

Vue helps to add custom attributes on existing elements via "directives" -Attribute Directives

Directive is object, which encapsulate the logic of that attribute

Attribute directives syntax
.............................

v-directiveName

Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak

..................................................................................
			    v-html and v-text
...................................................................................

v-html :
 inserts data into html element as "HTML"
{{}} 
  inserts data into html element as "Plain Text"

				v-text

Update the element's text content. - innerText

<span v-text="msg"></span>
<!-- same as -->
<span>{{msg}}</span>

<script setup>
const firstName = "Subramanian"
</script>
<template>
    <div>
        <h1>Inter polation using mustache Notation</h1>
        <h2>First Name {{ firstName }}</h2>
        <h1>Inter polation using directive - innerHTML</h1>
        <h2 v-html="` First Name ${firstName}`"></h2>
        <h1>Inter polation using directive - innerText</h1>
        <h2 v-text="` First Name ${firstName}`"></h2>
    </div>
</template>
..................................................................................
			       v-bind
.................................................................................

v-bind binds html element attributes or component values(properties) dyamically.

Static binding
 <img src="logo.png"/>

dynamic binding
 if img location is given inside script as variable, now i want to bind that image to img element
<script>
  const imageUrl="logo.png"
</script>

<img v-bind:src="imageUrl"/>
  
<script setup>
const imageUrl = "/src/assets/logo.svg"
</script>
<template>
    <div>
        <h1>Bind Directives</h1>
        <div>
            <h2>Static Image</h2>
            <img src="./assets/logo.svg" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Image using v-bind Directive</h2>
            <img v-bind:src="imageUrl" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Image using v-bind Directive -shortcut</h2>
            <img :src="imageUrl" height="100" width="100" />
        </div>
    </div>
</template>
....................................................................................
			     Data  Representation in Vue
....................................................................................

Data can be reprsented inside component in two ways

1.state pattern
   The data is encasulated inside component itself
2.props pattern
   The data is supplied from outside(parent component)


State Pattern:

 Data is two type

data can be both primitive or objects(arrays)
 
1.Non Reactive 

2.Reactive 

Non Reactive data when you change /update, never tigger render cycles of view

eg:
<script>
export default {
    setup() {
        //state- non reactive
        const counter = 0
        return {
            counter
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
    </div>
</template>

if you want to change data, we need to interact with UI, we need event handling
....................................................................................
				Event Handling
...................................................................................

There are two things in order to write event handling

1.Attach event on dom element
2.Listen on particular event using listeners or handlers

How to attach events and bind listeners , How to write listeners?

Listners are simple javascript function

<script>
export default {
    setup() {
        //state- non reactive
        const counter = 0

        //listener
        function onIncrement() {
            console.log('onIncrement is called')
        }

        return {
            counter, onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
    </div>
</template>

....

How to bind events?

 There is a directive called "v-on:nameOftheEvent" directive
 v-on:click="handler"
 We have even short cut
 @click="handler"

<script>
export default {
    setup() {
        //state- non reactive
        const counter = 0

        //listener
        function onIncrement() {
            console.log('onIncrement is called')
        }

        return {
            counter, onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>

    </div>
</template>
.....................................................................................
                           State Mutation -  change/update
....................................................................................

<script>
export default {
    setup() {
        //state- non reactive
        let counter = 0

        //listener
        function onIncrement() {
            console.log('onIncrement is called')
            //update the state
            counter++
            console.log(`Counter ${counter}`)

        }

        return {
            counter, onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>

    </div>
</template>

Here we are trying to update the counter state variable, there is update happening but it does not trigger "view update"
   Because the state is non reactive...
...................................................................................
				Reactivity
...................................................................................


What is Reactivity?

Reactivity is one of the core vue js concept.
Component state are reactive javascript objects.

When we modify them, the view updates.

Reactivity is a programming style that allows us to adjust to changes in declartive manner.

eg:
Excel spreed sheet is one of the best eg for reactivitity programming

eg;

let A1=1
let A2=2
let A3 =A1+A2
console.log(A3) => 3

A2=4

console.log(A3) 

Here when you mutate A1 or A2, does not change automatically.

How to implement to trigger this changes in js?

We can wrap this code inside function

 let A3
 function update(){
   A3 = A1 + A2
 }

in order get fresh value, we have to re-run the code that updates A3

Pointers:

1.There should be some update function, which produces a "side effect /effect".
  if any function which changes the state of the program called side effect.

2.Here ,A1 and A2 are considered dependencies of the side effect, because which helps makes side effects.
  According to dependencies, this effect is said to be "subscriber"

When ever "A1 and A2" changed, we need to invoke "update" function,which cause side effects.

It looks like event driven programming (Pub-Sub Pattern /Observerable and Observer) 

 function whenDepChange(update){
     update()
 }

 let A3
 function update(){
   A3 = A1 + A2
 }

 whenDepChange(function(){
     A3 = A1 + A2
 })
 whenDepChange(update)

Role of whenDepchange function:
................................

1.Tracking the dependencies,
    By evaulating the expression A1 and A2 ,Whether any one of them is read or not.

Tracker--->triggers--whenDepChange--->runs update function---returns modified state

....................................................................................
			   How vue implements Reactivity
.....................................................................................

There are two patterns have implmented in order to implement reactivity

1.Getters and Setters of Object to be changed 
   Vue 2 has implmented this pattern
  Still this pattern is available in V3 as well

2.Javascript Proxy pattern
   Vue 3 has implemented Proxy for Reactivity.


When we use SFC using Compostion Api pattern
  reactivity implementations are given as apis

When we use SFC using Options Api Pattern
  reactivity implementations are given inside "data" method 
 Options api uses only "Getters and Setters" Pattern
  

Compostion Api pattern:

ref()
computed()
reactive()
readonly()
watchEffect()
watchPostEffect()
watchSyncEffect()
watch()

How to represent reactive State?

ref api
 Used for primitives -strings,numbers,booleans
 objects can be used but avoid.
reactive api
 Used for objects and arrays.


eg:
<script>
//imort reactive apis
import { ref } from 'vue'

export default {
    setup() {
        //reactive state
        let counter = ref(0)
        console.log(counter.value)

        //listener
        function onIncrement() {
            console.log('onIncrement is called')
            //update the state
            counter.value++
            console.log(`Counter ${counter.value}`)
        }

        return {
            counter, onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>

    </div>
</template>

Reactivity with script setup attribute
<script setup>
//imort reactive apis
import { ref } from 'vue'

//reactive state
let counter = ref(0)
//listener
const onIncrement = () => counter.value++
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>
    </div>
</template>

..................................................................................
			State Mutation using Options Api
...................................................................................

<script>
export default {
    data() {
        //reactive state
        return {
            counter: 0
        }
    },
    //listeners
    methods: {
        onIncrement() {
            this.counter++
        }
    }

}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
        <!-- <button v-on:click="onIncrement">increment</button> -->
        <button @click="onIncrement">increment</button>
    </div>
</template>
....................................................................................
			Mulitiple Listeners and State mutation
....................................................................................
<script setup>
import { ref } from 'vue';
const counter = ref(0)

//two listeners
const onIncrement = () => counter.value++
const onDecrement = () => counter.value--

</script>
<template>
    <div>
        <h1>Counter Application</h1>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>
    </div>
</template>
<style>
</style>
....................................................................................
			 Multiple Reactive State Variables
<script setup>
import { ref } from 'vue';

//reactive states
const like = ref(0)
const dislike = ref(0)

//two listeners
const onLike = () => like.value++
const onDislike = () => dislike.value++

</script>
<template>
    <div>
        <h1>Like and DisLike Application</h1>
        <h1>Likes {{ like }} DisLike {{ dislike }}</h1>
        <button @click="onLike">Like</button>
        <button @click="onDislike">Dislike</button>
    </div>
</template>
<style>
</style>
...................................................................................
			 How to declare objects

<script setup>
import { reactive } from 'vue';

//reactive object
const counter = reactive({
    count: 0
})
console.log(counter.count)
const onIncrement = () => counter.count++

</script>
<template>
    <div>
        <h1>Counter Application</h1>
        <h1>Counter {{ counter.count }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>
<style>
</style>
.................................................................................
			 Reactivity for Object and its nested Object

In vue, state is deeply reactive by default, This means you can change inner objects 
which is reactive.

<script setup>
import { reactive } from 'vue';

//reactive  deep nested objects
const app = reactive({
    counter: {
        inc: {
            count: 0
        }
    }
})
const onIncrement = () => app.counter.inc.count++

</script>
<template>
    <div>
        <h1>Counter Application</h1>
        <h1>Counter {{ app.counter.inc.count }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>
<style>
</style>
.....................................................................................
			Arrays Rendering- List Rendering
....................................................................................

Arrays:
=>Arrays are basic datastructure which is used to render collection of data.
=>Arrays are dynamic 

Arrays and UI
 if you want to render more data , then array is used..
Arrays can help to build in UI layouts in various ways

Layouts:

1.List View
  <ul><li></li></ul>

2.Card View layout
   <div> <header>....

3.Grid View layout
   <table>

How to iterate array inside template?
 
 We have special directive called "v-for"
 <script setup>
import { reactive } from 'vue';
import TODOS from './mock-data/todos';

const todos = reactive(TODOS)

</script>
<template>
    <div>
        <h1>Todo List</h1>
        <ul>
            <li v-for="todo in todos">
                <span>{{ todo.id }} {{ todo.title }}</span>
            </li>
        </ul>
    </div>
</template>
...................................................................................
			List with Index
...................................................................................


<script setup>
import { reactive } from 'vue';

const list = reactive([
    {
        id: 1,
        name: 'A'
    },
    {
        id: 2,
        name: 'B'
    },
    {
        id: 3,
        name: 'A'
    }
])
</script>
<template>
    <div>
        <h1>List- with Index</h1>
        <ul>
            <li v-for="(item, index) in list">
                <span>{{index}} - {{ item }}</span>
            </li>
        </ul>
    </div>
</template>
.................................................................................
				key

if there is reordering in the list when we do some changes like sorting,filtering
vue uses an algorthim called patch..
We can tell to that algorthim how we can re arrange. thats where key attribute comes into picture.
key value must be unquire

<script setup>
import { reactive } from 'vue';
import TODOS from './mock-data/todos';

const todos = reactive(TODOS)

</script>
<template>
    <div>
        <h1>Todo List</h1>
        <ul>
            <li v-for="todo in todos " :key="todo.id">
                <span>{{ todo.id }} {{ todo.title }}</span>
            </li>
        </ul>
    </div>
</template>
....................................................................................
			 Nested List(nested Array)


<script setup>
import { reactive } from 'vue';

const persons = [
    {
        id: 1,
        name: 'A',
        friends: [
            {
                name: 'F1'
            },
            {
                name: 'F2'
            },
            {
                name: 'F3'
            }
        ]
    },
    {
        id: 2,
        name: 'A1',
        friends: [
            {
                name: 'B1'
            },
            {
                name: 'B2'
            },
            {
                name: 'B3'
            }
        ]
    },
    {
        id: 3,
        name: 'A2',
        friends: [
            {
                name: 'C1'
            },
            {
                name: 'C2'
            },
            {
                name: 'C3'
            }
        ]
    }
]
const list = reactive(persons)
</script>
<template>
    <ul>
        <li v-for="person in list">
            <span>{{ person.id }} {{ person.name }}</span>
            <ul>
                <li v-for="friend of person.friends">
                    <span>{{ friend.name }}</span>
                </li>
            </ul>
        </li>
    </ul>


</template>
.....................................................................................				 Object as iterable
......................................................................................
<script setup>
import { reactive } from 'vue';

const movie = reactive({
    title: 'The Matrix',
    langague: ['English', 'Spanish', 'Hindi', 'Tamil', 'Telgu'],
    hours: '2 hrs 5 mins'
})

</script>
<template>
    <ul>
        <li v-for="tmpMovie in movie">
            <span>{{tmpMovie}}</span>
        </li>
    </ul>

</template>
.....................................................................................
		 Range - If you want to repeat something n of times
....................................................................................
<script setup>
import { ref } from 'vue';

const start = ref(1)
</script>
<template>
    <ul>
        <li v-for="start in 100">
            <span>{{ start }}</span>
        </li>
    </ul>

</template>
..................................................................................
			Template and v-for
.................................................................................
<script setup>
import { reactive } from 'vue';
import todos from './mock-data/todos';

const TODOS = reactive(todos)
</script>
<template>
    <template v-for=" todo in todos">
        <h1>Todo Id {{ todo.id }}</h1>
        <p>Status {{ todo.completed ? 'Completed' : 'Not Completed' }}</p>
    </template>

</template>
....................................................................................
		   We can repeat Components
....................................................................................

<Item v-for="n in 10"></Item>

<script setup>
import { ref } from 'vue';
import Greeter from './components/greeter/Greeter.vue';

const start = ref(1)
</script>
<template>
    <Greeter v-for="start in 5"></Greeter>
</template>
.....................................................................................
			 Array Mutations
.....................................................................................
<script setup>
import { reactive } from 'vue';

const todos = reactive([])
const addItem = () => {
    //array mutation - add element into array
    todos.push({
        id: Math.random(),
        text: 'do this '
    })
}
</script>
<template>
    <ul>
        <li v-for="todo in todos">
            {{ todo }}
        </li>
    </ul>
    <button @click="addItem">Add New Item</button>
</template>

In Array all apis will not trigger render cycle.

Apis which trigger render cycle; -Mutating apis

1.push
2.pop
3.shift
4.unshift
5.splice
6.sort
7.reverse

.....................................................................................
			Filtering/sorting arrays with Immutable api
<script setup>
import { ref } from 'vue';
import TODOS from './mock-data/todos';

const todos = ref(TODOS)

const filter = () => todos.value = todos.value.filter(todo => todo.completed)

</script>
<template>
    <button @click="filter">filter</button>

    <ul>
        <li v-for="todo in todos">
            {{ todo }}
        </li>
    </ul>

</template>

..................................................................................
			Object destructuring and state Mutation
.................................................................................. 

<script setup>
import { reactive } from 'vue';

// const location = reactive({
//     lat: 10.5,
//     lng: 90.5
// })
const { lat, lng } = reactive({
    lat: 10.5,
    lng: 90.5
})

const updateLocation = ()=>{
    lat = 22
}
</script>
<template>
    <div>
        <!-- <p>Lat {{ location.lat }}</p>
        <p>Lng {{ location.lng }}</p> -->
         <p>Lat {{ lat }}</p>
        <p>Lng {{ lng }}</p>
        <button @click="updateLocation">Update Location</button>
    </div>
</template>

here reactive will not trigger for after destructure

toRef
toRefs

const location = reactive({
    lat: 10.5,
    lng: 90.5
})

let { lat, lng } = toRefs(location)

let { lat, lng }  = toRefs(reactive({
    lat: 10.5,
    lng: 90.5
}))
or
..

<script setup>
import { reactive,toRefs } from 'vue';

const location = reactive({
    lat: 10.5,
    lng: 90.5
})
let { lat, lng } = toRefs(location)

const updateLocation = () => {
    lat.value = 22
}
</script>
<template>
    <div>
        <p>Lat {{ lat }}</p>
        <p>Lng {{ lng }}</p>
        <button @click="updateLocation">Update Location</button>
    </div>
</template>
...................................................................................
			  Computed Properties
...................................................................................

<script setup>
const products = [
    {
        id: 1,
        name: 'books',
        items: [
            "Vue in Action",
            "Vue Master Class"
        ]
    },
    {
        id: 2,
        name: 'electronics',
        items: []
    },
    {
        id: 3,
        name: 'food',
        items: [
            "Rice"
        ]
    },
    {
        id: 4,
        name: 'building material',
        items: []
    }
]
</script>
<template>
    <ul>
        <li v-for="product in products">
            <span>Id {{ product.id }} Name {{ product.name }} Stock {{ product.items.length > 0 ? 'In Stock' : 'OutOfStock' }}
            </span>
        </li>
    </ul>
</template>

Here we have written "expression inside template", which is not recommended 

=>The code is not declarative (dont write any js logic)
=>The code is not maintainable , later if you want to change any display message.

We have to isloate the template expression logic into a separate method called as 
"computed property"

Computed property is written using "computed" api.

<script setup>
import { computed, reactive } from 'vue';

const products = reactive({
    id: 1,
    name: 'books',
    items: [
        "Vue in Action",
        "Vue Master Class"
    ]
})

const stockInfo = computed(() => {
    return products.items.length > 0 ? 'InStock' : 'OutofStock'
})
</script>
<template>
    <div>
        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ products.items.length > 0 ? 'InStock' :
                'OutofStock'
        }}</h3>

        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ stockInfo }}</h3>
    </div>
</template>
.................................................................................
			Template logic in Regular methods

<script setup>
import { computed, reactive } from 'vue';

const products = reactive({
    id: 1,
    name: 'books',
    items: [
        "Vue in Action",
        "Vue Master Class"
    ]
})

const update = () => products.items.push("Demo")

const update1 = () => {
    products.id = 2
}

const stockInfo = computed(() => {
    console.log('computed is called')
    return products.items.length > 0 ? 'InStock' : 'OutofStock'
})
//regular /normal javascript method
const stockInfoRegular = () => {
    console.log('regular method is called')
    return products.items.length > 0 ? 'InStock' : 'OutofStock'
}

</script>
<template>
    <div>
        <h1>Javascript Expression inside Template</h1>
        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ products.items.length > 0 ? 'InStock' :
                'OutofStock'
        }}</h3>

        <h1>Javascript Expression as ComputedProperty</h1>

        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ stockInfo }}</h3>

        <h1>Javascript Expression as Regular Method</h1>

        <h3>Product Id {{ products.id }} Name {{ products.name }} Stock {{ stockInfoRegular() }}</h3>

        <button @click="update">Render1</button>
        <button @click="update1">Render2</button>

    </div>
</template>

computed vs regular methods:
............................

computed is cached where regular methods is not cached.

computed is lazy , that means when ever the property is changed which is represented
inside computed method

computed method is called only reactive dependency.

computed method is always "getter method"
.....................................................................................
<script setup>
import { computed, ref } from 'vue';
const firstName = ref('Subramanian')
const lastName = ref('Murugan')

const fullName = computed(() => {
    return `${firstName.value} ${lastName.value}`
})

</script>
<template>
    <h1>Name {{ fullName }}</h1>
</template>
....................................................................................
			   Watchers
...................................................................................

Computed properties allow us to declaratively compute derived values. However, there are cases where we need to perform "side effects" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation

<script setup>
import { ref, watch } from 'vue';
const x = ref(0)

//watcher
watch(x, (newX) => {
    console.log(` X value is ${newX}`)
})

</script>
<template>
    <button @click="x++">+</button>
</template>
....................................................................................
			 Watch Multiple Properties
....................................................................................
<script setup>
import { ref, watch } from 'vue';
const x = ref(0)
const y = ref(0)
const z = ref(0)
//watch multiple sources
watch([x, y, z], ([tempX, tempY, tempZ]) => {
    console.log(`X ${tempX} Y ${tempY} Z ${tempZ}`)
})

</script>
<template>
    <button @click="x++">X</button>
    <button @click="y++">Y</button>

</template>
....................................................................................
			 How to watch literal object properties

<script setup>
import { reactive, ref, watch } from 'vue';

const counter = reactive({
    up: 0,
    down: 100
})
const increment = () => counter.up++
const decrement = () => counter.down--


//watch object particular property
watch(() => counter.up, count => {
    console.log(`Counter Inside Watch ${count}`)
    if (count > 10) {
        alert(' Volum is High')
    }
})

</script>
<template>
    <h1>Up : {{ counter.up }}</h1>
    <button @click="increment">+</button>
    <h1>Down : {{ counter.down }}</h1>
    <button @click="decrement">-</button>
</template>
...................................................................................
				Deep watching
..................................................................................
if you watch the whole reactive object , it will create a deep watcher, the callback will triggered if any property the object changes


<script setup>
import { reactive, ref, watch } from 'vue';

const counter = reactive({
    up: 0,
    down: 100
})
const x = ref(0);

const increment = () => counter.up++
const decrement = () => counter.down--


//watch  whole reactive object
//1st param is reactive object to be watched
//2nd param is reactive to be returned
//3rd param is only if there is different object
watch(counter, () => {
    console.log('watching...')
    return counter
}, (newValue, OldValue) => {
    //immutable 
    console.log(newValue, OldValue)
    return counter
}, { deep: true })


</script>
<template>
    <h1>Up : {{ counter.up }}</h1>
    <button @click="increment">+</button>
    <h1>Down : {{ counter.down }}</h1>
    <button @click="decrement">-</button>

    <button @click="x++">{{ x }}</button>

</template>
....................................................................................
			 watchEffect
.....................................................................................

watch is lazy, means called only if given state changes, watchEffect is executed atleast onece, and reexecuted whenever the property changes.

<script setup>
import { ref, watch, watchEffect } from 'vue'

// bind ref as a variable
let count = ref(0)

// watch(count, () => {
//     console.log(count.value)
// })
watchEffect(() => {
    console.log(count.value)
})

</script>
<template>
    <p>{{ count }}</p>
    <button @click="count++">+</button>
</template>
...................................................................................
			 Conditional Rendering -
..................................................................................


v-if and v-else:
................

<script setup>
import { computed, ref } from 'vue'
const name = ref('admin')

const isAdmin = computed(() => name.value === 'admin')

</script>
<template>
    <div>
        <!-- <h1 v-if="name === 'admin'">You are Admin</h1>
        <h1 v-else>You are guest</h1> -->
        <h1 v-if="isAdmin">You are Admin</h1>
        <h1 v-else>You are guest</h1>
    </div>
</template>

v-if takes boolean expression or truthy or falsy value, if it is true that block will be executed else, v-else block will be executed
v-if and v-else should be in the same place.


v-if on template
...............

Because v-if is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use v-if on a <template> element, which serves as an invisible wrapper. The final rendered result will not include the <template> element.

<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
v-else and v-else-if can also be used on <template>.

const ok = ref('something')
<template v-if="ok">
        <h1>Title</h1>
        <p>Paragraph 1</p>
        <p>Paragraph 2</p>
    </template>
    <template v-else>
        <h1>else Title</h1>
        <p>else Paragraph 1</p>
        <p>else Paragraph 2</p>
    </template>
....................................................................................
			 v-show

Another option for conditionally displaying an element is v-show directive, which is eq to v-if.

<h1 v-show="conditon">This is demo</h1>


v-if vs v-show:

v-if is "real" conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.

v-if is also lazy: if the condition is false on initial render, it will not do anything - the conditional block won't be rendered until the condition becomes true for the first time.

In comparison, v-show is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.

Generally speaking, v-if has higher toggle costs while v-show has higher initial render costs. So prefer v-show if you need to toggle something very often, and prefer v-if if the condition is unlikely to change at runtime.
<script setup>
import { computed, ref } from 'vue'
const name = ref('admin')

const isAdmin = computed(() => name.value === 'admin')

</script>
<template>
    <div>
        <!-- <h1 v-if="name === 'admin'">You are Admin</h1>
        <h1 v-else>You are guest</h1> -->
        <h1 v-if="isAdmin">You are Admin</h1>
        <h1 v-else>You are guest</h1>
    </div>
    <template v-if="isAdmin">
        <h1>You are admin</h1>
        <p>This is admin </p>
        <p>This is admin </p>
        <p>This is admin </p>
    </template>
    <template v-else>
        <h1>You are Guest</h1>
        <p>This is Guest </p>
        <p>This is Guest </p>
        <p>This is Guest </p>
        <p>This is Guest </p>

    </template>
    <h1 v-show="isAdmin">Admin Show</h1>
</template>
.....................................................................................
			Components and state (data patterns)
......................................................................................

Components stores data in the form of 

1.reactive state - ref,reactive
2.computed state
3.watchers
4.props pattern
.....................................................................................
				Props Pattern

Props means property.
The component receives data from the parent compoent , which is called property.
Props pattern inspired from react, which is based on design pattern called "Single directional data flow model" /Uni directional data flow model.

			<Parent>
			   |
			supply data 
			   |
 		        <Child>



How to pass props and how to received?

parent.vue
<script setup>
import Child from './Child.vue';
</script>
<template>
<h1>Parent Component</h1>
<hr/>
<Child message="Hello"></Child>
</template>

child.vue
<!-- <script>
export default {
    props: ['message'],
    setup(props) {
        //access props inside setup 
        console.log(props.message)

        return {
            props
        }
    }

} -->
<!-- </script>
<template>
    <h2>Child</h2>
    <h3>{{ props.message }} From the Parent Component </h3>
</template>  -->
<script setup>
const props = defineProps(['message'])
</script>
<template>
    <h2>Child</h2>
    <h3>{{ props.message }} From the Parent Component </h3>
</template>
.....................................................................................
				Props types


1.static props
   props which are hardcoded , mostly strings can be static prop
<Child message="Hello"></Child>

2.dynamic props
  props can be updated via reactivity .
<Child v-bind:message="Hello"></Child>
<Child :message="variable/expressions"></Child>

Parent.vue
<script setup>
import { ref } from 'vue';
import DyamicProp from './DynamicProp.vue';

const name = ref('Subramanian')
const age = ref(18)
const status = ref(true)
</script>
<template>
    <h1>Parent Component</h1>
    <hr />
    <DyamicProp :name="name" :age="age" :status="status"></DyamicProp>

</template>


DynamicProps.vue

<script setup>
const props = defineProps(['name', 'age', 'status'])
</script>
<template>
    <h2>Dynamic Prop Component</h2>
    <div>
        <p>Name {{ props.name }}</p>
        <p>Age {{ props.age }}</p>
        <p>Status {{ props.status }}</p>
    </div>
</template>
...................................................................................
				Default Props

what if i dont supply any props, then it will be undefined

With props  supplied
 <DyamicProp :name="name" :age="age" :status="status"></DyamicProp>

without any props supplied
<DyamicProp></DyamicProp>
   here all properties will be undefined.

How to set default props.
with object literal syntax.

DynamicProp.vue
<script setup>
// const props = defineProps(['name', 'age', 'status'])
//literal syntax with default value
const props = defineProps({
    name: {
        default: 'default Name'
    },
    age: {
        default: 18
    },
    status: {
        default: false
    }
})
</script>
<template>
    <h2>Dynamic Prop Component</h2>
    <div>
        <p>Name {{ props.name }}</p>
        <p>Age {{ props.age }}</p>
        <p>Status {{ props.status }}</p>
    </div>
</template>


Parent.vue
<script setup>
import { ref } from 'vue';
import DyamicProp from './DynamicProp.vue';

const name = ref('Subramanian')
const age = ref(18)
const status = ref(true)
</script>
<template>
    <h1>Parent Component</h1>
    <hr />
        <!-- With props -->
    <DyamicProp :name="name" :age="age" :status="status"></DyamicProp>
    <!-- Without props -->
    <DyamicProp></DyamicProp>
</template>
....................................................................................
			 Property Validation
....................................................................................

Some times i want to enforce the property data type validation, which is only for runtime vertification.

eg:
 i have property called age
 i need to define rule for age that age must be number,it should not be string.

eg:
  defineProps({
     age:Number,  
     id: [Number,String] // can be string or can be number
     name: {
      type:String
      required:true,
      default:'name'
     },
    status: {
	validator(value){
	  return ['OK','NotOk','Success','Failure'].includes(value)
       }
    }
 })

Runtime Types:
1.String
2.Number
3.Boolean
4.Array
5.Object
6.Date
7.Function
8.Symbol

eg:
<script setup>
import { ref } from 'vue';
import PropValidation from './PropValidation.vue';

const name = ref('Subramanian')
const age = ref(18)
const status = ref(true)
</script>
<template>
    <h1>Parent Component</h1>
   <PropValidation></PropValidation>
</template>
<script setup>
const props = defineProps({
    name: {
        type: String,
        default: 'name',
        required: true
    },
    age: {
        type: Number,
        default: 1
    }
})
</script>
<template>
    <h1>Property validation</h1>
    <div>
        <p>Name {{ props.name }} Age : {{ props.age }}</p>
    </div>
</template>

if any validation violation, the vue will give warning only, it will not stop rendering 

Vue warn]: Missing required prop: "name" 
  at <PropValidation> 
  at <Parent> 
  at <App>
...................................................................................
				Boolean Casting

props with boolean type has some special casting rules to mimic the behaviour of native boolean attributes.

eg: In the dom, these attributes by default has false values
 <div disabled> ==  <div disabled=false>
 <div hidden> 

In the similar pattern we can supply boolean values to the component,default value is true.

<PropValidation status></PropValidation> => true


<PropValidation></PropValidation> => false

Note: for booleans we dont need to supply default value,if you want  you can 
...................................................................................
			  One way data Flow

All props form a  oneway data flow model, child component cant update the props 

                         "Props are read only"



Parent.vue
<script setup>
import ChildPropMutation from './ChildPropMutation.vue';
</script>
<template>
    <h1>Parent Component</h1>
 <ChildPropMutation name="Subramanian"></ChildPropMutation>
</template>

ChildPropMutation.vue

<script setup>
const props = defineProps({
    name: String
})
//update the prop
props.name = "Foo"
</script>
<template>
    <h1>Prop Mutation {{props.name}}</h1>
</template>

You will get warning:
Set operation on key "name" failed: target is readonly. Proxy {name: 'Subramanian'}

=>Props cant be modified by child components, which never triggers render cycle

Use cases For Prop modification:

1.The prop is used to pass in an inital value; the child component wants to use it as a local data property afterwards.

<script setup>
import CounterProp from './CounterProp.vue';
</script>
<template>
    <h1>Parent</h1>
    <CounterProp :initalCounter="10"></CounterProp>
</template>

<script setup>
import { ref } from 'vue'
const props = defineProps(['initalCounter'])
//prop as state
const counter = ref(props.initalCounter)
</script>
<template>

    <h1>Counter State {{ counter }}</h1>
    <h1>Counter Props {{ props.initalCounter }}</h1>
    <button @click="counter++">+</button>
</template>
....................................................................................
			 dynamic props

The state of parent component can be passed as prop to child compoent.

Parent.vue
<script setup>
import { ref } from 'vue'
import StateAsProp from './StateAsProp.vue';

const counter = ref(10)

</script >
<template>
    <h1>Parent</h1>
    <StateAsProp :counter="counter"></StateAsProp>
    <button @click="counter++">+</button>
</template>


StateAsProp.vue
<script setup>
const props = defineProps(['counter'])
</script>
<template>
    <h1>State As Prop {{ props.counter }}</h1>
</template>
.....................................................................................
				Component Communications

Components can communicate each other in order to share "data".

There are three patterns

1.parent to child
    via props pattern we can share data from the parent to child
2.child to parent
   Custom Events- Event emitter pattern
3.across components
    Via State management libs - Vuex/Pionon

.....................................................................................
				 Event Emitter Pattern
.....................................................................................

Child component can emit event with data, where as parent component can listen for data.

Parent.vue
<script setup>
import { ref } from 'vue';
import ChildEventEmitter from './ChildEventEmitter.vue';

const message = ref('')
const counter = ref(0)

//listener 
function update(data) {
    console.log(data)
    message.value = data
}
function onCounterUpdate(count) {
    counter.value = count;
}
</script>
<template>
    <h1>Custom Events- Parent Component {{ message }} {{ counter }}</h1>
    <hr />
    <ChildEventEmitter @on-request="update" @on-counter="onCounterUpdate"></ChildEventEmitter>
</template>

ChildEventEmitter.vue

<script setup>
import { ref } from 'vue'
//define events 
const emit = defineEmits(['onRequest', 'onCounter'])

const data = ref('Hello,I am From Child Listener')
const counter = ref(0)
const sendToParent = () => {
    //emit event
    emit('onRequest', data.value)
}
const onIncrement = () => {
    //emit event
    emit('onCounter', counter.value++)
}

</script>
<template>
    <h1>Custom Events- Child Component</h1>
    <div>
        <button @click="$emit('onRequest', 'Hello,I am from Child')">Send Data To Parent</button>
    </div>
    <div>
        <button @click="sendToParent">Send Data To Parent</button>
    </div>
    <div>
        <button @click="onIncrement">Send Counter To Parent</button>
    </div>
    <hr />
</template>
.....................................................................................
	   Sending HTML attributes from Parent Component to Child
	        Components : Fallthrough Attributes
.....................................................................................

Attribute inheritance:
.....................

A fallthrough attribute is an attribute or v-on listeners that is passed to component but it is not explicitly declared in the receiving component(child components) via props or emits

Parent

 <child :message="message"></child>

Child
<script setup>
  const props =defineProps['message']
</script>

Common attributes are sent from parent to child:
.................................................

1.class
2.style
3.id

....
eg:

MyButton.vue
 Child Component template
<button>click</button>

Parent.vue
<MyButton :message="test" ></MyButton>


Parent.vue

<script setup>
import ChildAttribute from './ChildAttribute.vue';
</script>
<template>
    <h1>Parent Component</h1>
    <ChildAttribute class="fancy-btn " label="ClickMe"></ChildAttribute>
</template>
<style>
.fancy-btn {
    color: #fff;    
}
</style>
.................................................................................
if child component root component already has style or class attributes, which to be merged with child components.
.....................................................................................

How to attach listener and Event

Parent Component event listener can be bound to child dom elements, From the child component parent's component listener can be invoked directly.

Parent.vue
<script setup>
import ChildAttribute from './ChildAttribute.vue';

//parent listener
const onUpdate = () => {
    alert('Parent listner')
}

</script>
<template>
    <h1>Parent Component</h1>
    <ChildAttribute  @click="onUpdate"    class="fancy-btn " label="ClickMe"></ChildAttribute>
</template>
<style>
.fancy-btn {
    color: #fff;
}
</style>



ChildAttribute.vue
<script setup>
const props = defineProps(['label'])
</script>
<template>
    <button class="large">{{ props.label }}</button>
</template>
<style>
.large {
    color: rgb(228, 7, 7);
    background: linear-gradient(315deg, #42d392 25%, #647eff);
    border: none;
    padding: 5px 10px;
    margin: 5px;
    border-radius: 8px;
    cursor: pointer;
}
</style>
.....................................................................................
			 How to prevent Attribute inheritance

// script without setup attribute
<script>
  export default {
    inheritAttrs:false
  }
</script>
<script setup>

</script>

ChildAttribute.vue
<script>
export default {
    inheritAttrs: false
}
</script>
<script setup>
const props = defineProps(['label'])
</script>
<template>
    <button>{{ props.label }}</button>
</template>
<style>
.large {
    color: rgb(228, 7, 7);
    background: linear-gradient(315deg, #42d392 25%, #647eff);
    border: none;
    padding: 5px 10px;
    margin: 5px;
    border-radius: 8px;
    cursor: pointer;
}
</style>
.....................................................................................					Slots -Component as Prop
....................................................................................

How to represent component?

<MyComponent></MyComponent>
<MyComponent/>


<MyComponent>
    you are sending component /html elements  => slot content
</MyComponent>

ParentSlot.vue

<script setup>
import ChildSlot from './ChildSlot.vue';
import Header from './Header.vue';
</script>
<template>
    <h1>Parent - Slot</h1>
    <!-- we send html elements as prop -->
    <ChildSlot>
        <h1>Hello</h1>
    </ChildSlot>
    <!-- another component as prop -->
    <ChildSlot>
        <Header />
    </ChildSlot>
</template>

ChildSlot.vue
<script setup>

</script>
<template>
    <div>
        <!-- insert template content from the parent -->
        <slot></slot> <!-- Slot is built in component called outlet(wrapper/container)-->
    </div>
</template>
...................................................................................
				Fallback Content

Eg:

<MyComponent>
    some content
</MyComponent>

Mycomponent.vue

<template>
  <div>
       <slot></slot>
  </div>
</template>

Parent.vue
<script setup>
import Child from './Child.vue';
</script>
<template>
    <h1>Slot Parent</h1>
 <Child>
        <h1>From the parent</h1>
 </Child>
 <Child/>
</template>

Child.vue
<script setup>
</script>
<template>
    <h1>Slot Child</h1>
    <div>
        <slot>
            <p>default slot content /fallback content</p>
        </slot>
    </div>
</template>
.....................................................................................
			     Muliti Slots
.....................................................................................

Can i have multi slot?
 Yes we can have

Without slot
<Layout>
  <Header/>
  <Body/>
  <Footer/>
</Layout>

<Layout>
  <Header>
    <!---Header information--->
  </Header>
  <Body>
    <!---Body information--->
  </Body>
  <Footer>
    <!---Footer information--->
  </Footer>
</Layout>
....................................................................................

We can achive multi slots using named slots concept

Each slot can have name which can be further mapped in the parent compoent

child
<slot name="header"></slot>

parent
<template v-slot:header>

</template>
..............................

App.vue/Parent
<script setup>
import Layout from './slots/Layout.vue';

</script>
<template>
    <h1>Vue Application</h1>
    <hr />
    <Layout>
        <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>



Layout.vue
<script setup>
</script>
<template>
    <h1>Layout</h1>
    <hr />
    <div class="container">
        <header>
            <slot name="header">
                <h1>default Header</h1>
            </slot>
        </header>
        <main >
            <slot name="main">
                <p>default content</p>
            </slot>
        </main>
        <footer>
            <slot name="footer">
                <h2>default footer</h2>
            </slot>
        </footer>
    </div>
</template>

short cuts to refer slots:

without v-slot directive , we can use #name 

<Layout>
        <template #header>
            <h1>Header</h1>
        </template>
        <template #main>
            <p>This is body</p>
        </template>
        <template #footer>
            <h1>Footer</h1>
        </template>
    </Layout>
.................................

Default slot:
     The slot without name is called default slot
child
<template>
    <h1>Layout</h1>
    <hr />
    <div class="container">
        <header>
            <slot name="header">
                <h1>default Header</h1>
            </slot>
        </header>
        <!-- Default slot : without any name -->
        <main>
            <slot>
                <p>default content</p>
            </slot>
        </main>
        <footer>
            <slot name="footer">
                <h2>default footer</h2>
            </slot>
        </footer>
    </div>
</template>

parent
<template #default>

</template>

eg:

<template>
    <Layout>
        <template #header>
            <h1>Header</h1>
        </template>
        <template #default>
            <p>This is body</p>
        </template>
        <template #footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>
....................................................................................
				Dynamic slots

The slot name can be dynamic

static slot name

<template v-slot:header>
<template #header>

Dynamic slot name

const header = ref('header')

<template v-slot:[header]>
<template #[header]>


eg:
<script setup>
import { ref } from 'vue';
import Layout from './slots/Layout.vue';

const header = ref('header')

</script>
<template>
  <Layout>
        <!-- <template v-slot:[header]>
            <h1>Header</h1>
        </template> -->
        <template #[header]>
            <h1>Header</h1>
        </template>
        <template #default>
            <p>This is body</p>
        </template>
        <template #footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>
....................................................................................
				Slot Scopes

Slot scopes enable data accessiblity for parent and child

There are two scopes:
1.Render scope
2.Scoped slots

Render Scope:

=>The slot content has acccess to the data scope of the parent compoent, since it is defined in the parent component 

=>slot content does not have access to the child compoent's data.

     "As rule of thumb Every thing in the parent template is compiled in 
      Parent scope; every thing is compiled in the child template in the child
      scope"

Scoped Slot:
...........
   if you want to access data in the parent and child scope.
  
  "If parent component want to access child data(state) , the child can pass data 
   to parent via "slot" when rendering it.
   
   Slot can act as bridge between child and parent.

Child:

 <slot :name="name" :age="age"...>

Parent
  <MyComponent v-slot="variableName">
        
  </MyComponent>



Parent:
<script setup>
import { ref } from 'vue';
import ScopeSlot from './slots/ScopeSlot.vue';
</script>
<template>
    <h1>Vue Application</h1>
    <hr />
    <!--Scoped Slots : Sending data from the child to Parent  -->
    <ScopeSlot v-slot="slotProps">
        {{ slotProps.message }}
    </ScopeSlot>

</template>

child
<script setup>
import { ref } from 'vue';
const message = ref('From Child')
</script>
<template>
    <div>
        <!-- Send data to the parent compoent -->
        <slot :message="message"></slot>
    </div>
</template>
..............................................................................	
			  Depedency Injection - Provide/Inject
..............................................................................			  
Prop Driling:

 When you pass data from the parent component to child, from child to its child and so on, at each level you have to pass props manually

                        Root
			 |
			props
			 |
			Child1
			 |props
			Child2
			 |props
			Child3
			 |props
		        Child-N

Parent - App.vue
<script setup>
import { ref } from 'vue';
import Child1 from './propsdrilling/Child1.vue';
const message = ref('Hello')
</script>
<template>
    <h1>Root</h1>
    <Child1 :message="message" />
</template>

Child1.vue
<script setup>
import Child2 from './Child2.vue';
const props = defineProps(['message'])
</script>
<template>
    <h1>Child 1</h1>
    <Child2 :message="props.message" />
</template>

Child2.vue
<script setup>
import Child3 from './Child3.vue';
const props = defineProps(['message'])

</script>
<template>
    <h1>Child 2</h1>
    <Child3 :message="props.message" />
</template>

Child3.vue
<script setup>
const props = defineProps(['message'])

</script>
<template>
    <h1>Child 3 {{ props.message }}</h1>
</template>

What if  i want to access the data which is supplied in the root component into the deepest child component.

We can solve props drilling with "provide and inject".

Parent component can act as dependency provider to all its decendants.

Any component in the decendants tree, regardless of how deep it is, can inject dependencies provided by components up in its parent chain.

  			Root -  Provide
			 |        |
			props     |
			 |        |
			Child1    |
			 |        |
			Child2    |
			 |        |
			Child3    |
			 |        |
		        Child-N - Inject


eg:
How to pass single variable and How to object ? and how to make it reactive?

Parent-App.vue

<script setup>
import { ref, provide } from 'vue';
import Child1 from './propsdrilling/Child1.vue';

const message = ref('Hello')
//dynamic provider
const counter = ref(0)
//provider data
// provide('name', 'Subramanian')
// provide('counter', counter)
//short cut
provide('info', {
    counter, message
})
</script>
<template>
    <h1>Root</h1>
    <Child1 :message="message" />
    <button @click="counter++">+</button>
</template>

....

Child Level
<script setup>
import { inject } from 'vue'
const props = defineProps(['message'])

// const name = inject('name', 'default Name')
// const counter = inject('counter', 0)
const { name, counter } = inject('info')
</script>
<template>
    <h1>Child 3 {{ props.message }}</h1>
    <h1>Global Data {{ name }} {{ counter }}</h1>

</template>
...................................................................................
			App Level Data sharing

You have to provide via app object.

app.provide('company','google')

main.js
import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .provide('company', 'google')
    .mount('#app')


In any component:
<script setup>
import { inject } from 'vue'
const props = defineProps(['message'])

// const name = inject('name', 'default Name')
// const counter = inject('counter', 0)
const { name, counter } = inject('info')
const company = inject('company')
</script>
<template>
    <h1>Child 3 {{ props.message }}</h1>
    <h1>Tree level Global Data {{ name }} {{ counter }}</h1>
    <h1>App level Global Data {{ company }}</h1>

</template>
.....................................................................................
			    Composables
....................................................................................

Composable is just plain javascript function that separates resuable stateful logic
(logic which has state).

When we build apps, either server side or client, we need some biz logic has to be reused across the application.

eg:
  Date formater, String utilities.


Mouse tracking:
 i want to get Mouse positions for that we write logic inside component.

Without resue:
, onUnmountedonMounted, <script setup>
//Track mouse positions and display on the screen
import { ref, onMounted,onUnmounted } from 'vue';

//state
const x = ref(0)
const y = ref(0)

//logic to update
function update(event) {
    console.log('moving....')
    x.value = event.pageX
    y.value = event.pageY
}
//Life cycles to register dom events
onMounted(() => {
    //register mouse listener
    window.addEventListener('mousemove', update)
})
onUnmounted(()=>{
     //register mouse listener
    window.removeEventListener('mousemove', update)
})
</script>
<template>
    <h1>Mouse Position x: {{ x }} y: {{ y }}</h1>
</template>

Here, we write logic to get Mouse positions in side app component, what if i want the same logic again inside another component.

Solution is : Composable.

src/composables/mousetracker.js

import { ref, onMounted, onUnmounted } from 'vue'

//all composable function starts with "use" convention only/ not synatx
export function useMouseTracker() {
    //state
    const x = ref(0)
    const y = ref(0)
    //logic
    function update(event) {
        console.log('moving....')
        x.value = event.pageX
        y.value = event.pageY
    }
    //Life cycles to register dom events
    onMounted(() => {
        //register mouse listener
        window.addEventListener('mousemove', update)
    })
    onUnmounted(() => {
        //register mouse listener
        window.removeEventListener('mousemove', update)
    })
    //return state as object and even logic : you can return any thing but should be encapsulated inside object
    return {
        x,
        y
    }

}

App.vue
 <script setup>
//import composable api
import { useMouseTracker } from './composables/mousetracker.js'
//invoke composable apis
const { x, y } = useMouseTracker()

</script>
<template>
    <h1>Mouse Position x: {{ x }} y: {{ y }}</h1>
</template>
.....................................................................................
			Ajax calls and Composablity
....................................................................................

Ajax calls you can do with help any ajax apis, vue has no opionion on that.

Popular implementation
1.fetch api
2.axios api


How to fetch data using fetch api:

<script setup>
import { ref, onMounted } from 'vue'

//state variables
const data = ref(null)
const error = ref(null)

//function api
function fetchData() {
    fetch('https://jsonplaceholder.typicode.com/todos')
        .then(res => res.json())
        .then(todos => {
            data.value = todos
            console.log(data.value)
        })
        .catch(err => {
            error.value = err
        })
}

onMounted(() => {
    //call fetch api
    fetchData();
})


</script>
<template>
    <div>
        <h1>Todo app</h1>
        <div v-if="error">Opps! Error Encountered : {{ error.message }}</div>
        <div v-else-if="data">
            <div v-for="todo of data">
                <p>{{ todo.title }}</p>
            </div>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>

</template>

Drawback in the above code:

1.ajax/fetch logic is tightly coupled with component.


How to write reusable ajax logic ?
 Composable api

composable/fetch.js
import { ref, onMounted } from 'vue'

export function useFetch(url) {
    //state variables
    const data = ref(null)
    const error = ref(null)
    //function api
    async function fetchData() {
        // fetch(url)
        //     .then(res => res.json())
        //     .then(output => {
        //         data.value = output
        //     })
        //     .catch(err => {
        //         error.value = err
        //     })
        try {
           // const output = await (await fetch(url)).json()
          //  const output = await res.json()
            data.value = await (await fetch(url)).json()
        }
        catch (err) {
            error.value = err
        }
    }

    onMounted(() => {
        //call fetch api
        fetchData();
    })
    //return 
    return {
        data,
        error
    }

}

App.vue
<script setup>
import { useFetch } from './composables/fetch.js'

//with destructuring
const { data, error } = useFetch('https://jsonplaceholder.typicode.com/todos')
//without destructuring
// const todos = useFetch('https://jsonplaceholder.typicode.com/todos')

</script>
<template>
    <div>
        <h1>Todo app</h1>
        <div v-if="error">Opps! Error Encountered : {{ error.message }}</div>
        <div v-else-if="data">
            <div v-for="todo of data">
                <p>{{ todo.title }}</p>
            </div>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>

</template>

Now vue starts using lot of composable apis, which every growing....
https://vueuse.org/

eg:
<script setup>
import { useFetch } from './composables/fetch.js'
import { useTitle } from '@vueuse/core'


const title = useTitle('New Title', { titleTemplate: '%s | My Awesome Website' })

//with destructuring
const { data, error } = useFetch('https://jsonplaceholder.typicode.com/todos')
//without destructuring
// const todos = useFetch('https://jsonplaceholder.typicode.com/todos')


</script>
<template>
    <div>
        <h1>Todo app</h1>
        <div v-if="error">Opps! Error Encountered : {{ error.message }}</div>
        <div v-else-if="data">
            <div v-for="todo of data">
                <p>{{ todo.title }}</p>
            </div>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>

</template>
....................................................................................
			  Form Handling
.....................................................................................

Form Controls:
1.text / password
2.Multi line text
3.checkbox
4.radio
5.select

How to get input from the keyboard via form controls and bind in the ui

Syntax:

<input @input="listener" >

<script setup>
import { ref } from 'vue';
const name = ref("defaultName")
//listner
function getInput(event) {
    //read value from the text
    //  console.log(event.target.value)
    name.value = event.target.value
}
</script>
<template>
    <div>
        <h2>{{ name }}</h2>
        <input @input="getInput" />
    </div>
</template>

Two way data binding:

When ever user interacts via typing in the text box, the reactive variable is updated,
when ever reactive variable is updated, the UI is rerendered.

:value property  is used to initalize the default reactive state variable in side text box
<script setup>
import { ref } from 'vue';
const name = ref("defaultName")
//listner
function getInput(event) {
    //read value from the text
    //  console.log(event.target.value)
    name.value = event.target.value
}
</script>
<template>
    <div>
        <h2>{{ name }}</h2>
        <input @input="getInput" :value="name" />
    </div>
</template>

.....................................................................................
				How to reduce listeners
.....................................................................................

When we have more input fields, we need to write more event listeners, which can be avoided in two ways

1.inline event listener
<script setup>
import { ref } from 'vue';
const name = ref("defaultName")

</script>
<template>
    <div>
        <h2>{{ name }}</h2>
        <input @input="event => name = event.target.value" :value="name" />
    </div>
</template>

2.Using v-model directive

 ->It removes explicit event binding ,which attaches the default event handler and event automatically.
 

<script setup>
import { ref } from 'vue';
const name = ref("defaultName")

</script>
<template>
    <div>
        <h2>{{ name }}</h2>
        <input v-model="name" />
    </div>
</template>

v-model directive can be used on other input controls as well.

textarea
  it uses value property and input event
checkbox
radio
  It uses checked property and change event
select
 It uses value property and input event 

TextArea:
..........

Using Text area , we can get multi line input
<script setup>
import { ref } from 'vue';

const mail = ref('')

</script>
<template>
  
    <div>
        <h2>{{ mail }}</h2>
        <label id="mail">Mail</label>
        <textarea v-model="mail" />
    </div>
</template>

Checkbox 

Single Checkbox:
<script setup>
import { ref } from 'vue';
const checked = ref(true)

</script>
<template>
    <div>
        <input type="checkbox" id="checkbox" v-model="checked" />
        <label for="checkbox">{{checked}}</label>
    </div>
</template>
................................................................................
Multi Checkbox value collection:
...............................

<script setup>
import { ref } from 'vue';

const values = ref([])

</script>
<template>
    <div>
        <h1>Course Information</h1>

        <input type="checkbox" id="frontend" value="frontEnd" v-model="values" />
        <label for="frontend">Front End</label>
        <input type="checkbox" id="backend" value="BackEnd" v-model="values" />
        <label for="backend">Back End</label>
        <input type="checkbox" id="devops" value="Dev Ops" v-model="values" />
        <label for="devoops">Dev Ops</label>
    </div>
    <div>
        {{ values }}
    </div>
</template>
....................................................................................
Radio Button:
............
<script setup>
import { ref, computed } from 'vue';

const choice = ref("Male")


</script>
<template>
    <div>
        <h1>Select any One</h1>
        <input type="radio" id="Male" value="Male" checked v-model="choice" />
        <label for="Male">Male</label>
        <input type="radio" id="Female" value="Female" v-model="choice" />
        <label for="Female">FeMale</label>
    </div>
    <div>
        {{ choice }}
    </div>
</template>
.................................................................................

Select:
<script setup>
import { ref, computed } from 'vue';

const selected = ref('')
const courses = ref(["Vue", "React", "Angular", "MicroServices"])
const selectedCourse = ref('')
</script>
<template>
    <div>
        <select v-model="selected">
            <option disabled value>Select Your choice</option>
            <option>Vue</option>
            <option>React</option>
            <option>Angular</option>
            <option>MicroServices</option>
        </select>
    </div>
    <div>
        {{ selected }}
    </div>
    <hr />
    <div>
        <select v-model="selectedCourse">
            <option disabled value>Select Your choice</option>
            <option v-for="course of courses">{{ course }}</option>
        </select>
    </div>
    <div>
        {{ selectedCourse }}
    </div>
</template>
.................................................................................
Value Bindings -vue custom attributes:
....................................

v-model=""
true-value="yes" //replace true or false value into meaningfull values 
false-value="no"

<script setup>
import { ref } from 'vue';
const toggle = ref(true)
const truthyValue="Yes"
</script>
<template>
    <div>
        <input type="checkbox" :true-value="truthyValue" checked false-value="no" v-model="toggle" />
        <label for="Toggle">Toggle</label>
    </div>
    <div>
        <!-- {{toggle ? "Yes" : "No"}} -->
        {{ toggle }}
    </div>
</template>

For Radio button

:true-value=""

For Select options

:value="{text: 'some text'}"
....................................................................................
				Modifiers

if you want to change v-model behaviour, we can use modifiers

<input v-model="variable">
  Here Vue fires input event for every keystroke.
What if i want to add "change" event instead of input event

<input v-model.lazy="variable">
                |
       fires change event

Modifiers:

v-model.lazy -  fires change event
v-model.number -  converts strings into number
v-model.trim -  trims the leading strings
<script setup>
import { ref } from 'vue';
const msg = ref('')
const price = ref("10")
const mailid =ref('admin@foo.com')

</script>
<template>
    <div>
        <!-- <input v-model="msg" /> Input event -->
        
        <!-- Fire Change Event : once if the textbox looses its focus -->
        <label for="Name">Name</label>
        <input id="Name" v-model.lazy="msg" /> 

    </div>
        <div>
        
        <label for="Price">Price</label>
        <input id="Price" v-model.number="price" /> 

    </div>
      <div>
        
        <label for="mailId">mailId</label>
        <input id="mailId" v-model.trim="mailid" /> 

    </div>
    <div>
        <h1>{{ msg }}</h1>
        <h1>Price {{price}} Total Price {{price * 2}}</h1>
        <h1>{{mailid}}</h1>
    </div>
</template>
....................................................................................
		Form Submission and How to prevent default events
......................................................................................

In java script, when you submit form, automaticall there is event is fired , which is called "onSubmit" event.

onSubmit event by default looks the server url to be posted.
      <form action="http://www.google.com">
          <button  >Submit</button>
      </form>

Here , the button tries to redirecto url mentioned in the action property.

I need to control, the form submission manually.

Event Object :

has api called "preventDefault()" , which does not trigger auto form submission.


<script setup>

const onSubmit = event => {
    if (event) {
        event.preventDefault();
    }
}

</script>
<template>
    <div>
        <form action="http://www.google.com">
            <button @click="onSubmit">Submit</button>
        </form>
    </div>
</template>

Vue has some short cuts, instead of giving this inside listener, we can give inside templates.

Event Modifiers:
...............

Event Modifiers are used with v-on

<form @submit.prevent="onSubmit">
<script setup>

const onSubmit = event => {
    alert('Form to be Submitted')
}

</script>
<template>
    <div>
        <form @submit.prevent="onSubmit">
            <button>Submit</button>
        </form>
    </div>
</template>

Other event modifiers

//event propagation to be stopped
<a @click.stop="listner">

I want to submit form when key board events

<input @keyup.enter="onSubmit">

other keyboard keys modifiers

.enter
.tab
.left
.right
.space
.down
.up

.ctrl
.alt
.shift
.meta
.enter
.....................................................................................
				Custom Directives
.....................................................................................

Code Reuse in Vue:

The application code can be reused in vue in various ways.

1.Composables
   Way to reuse app state logic
2.Components
   Way to resue UI 
3.Directives 
   Way to resue underlaying dom features

There are different types of directives 

1.built in directives
   Directives are provided by vue - v-on,v-bind....
2.custom directives


How to create simple custom Directive?

Directive is object, having low level dom features.

Steps:

1.create directive object
<script setup>
//first directive
const vFocus = {
    //define life cycle methods
    mounted: (element) => {
        //we can get dom element here, what ever you want you can do
        console.log(element)
        element.focus()
    }
}
</script>

2.attach directive on html element.
<template>
    <input v-focus>
</template>




eg:
<script setup>
//high light directive
const vHightlight = {
    //define life cycle methods
    mounted: (element) => {
        //add event listener
        element.addEventListener('mousemove', (evt) => {
            //element.style.backgroundColor = 'yellow'
            highLight('yellow')
        })
        //remove style
        element.addEventListener('mouseleave', (evt) => {
            // element.style.backgroundColor = null
            highLight(null)
        })
        const highLight = (color) => {
            element.style.backgroundColor = color
        }
    }


}
</script>
<template>
    <h1 v-hightlight>HighLight</h1>

</template>


Directive Hooks:
  Directive hooks are methods which are called in every life cycle of directive

created(element,binding,vnode,prevNode)

beforeMount () - called before the target element is inserted into dom

mounted() -> called before the parent component is updated

beforeUpdate()- called after the parent component and all of its childern have updated

update() -called after beforeUpdate

beforeUnmount() - before removing element

unmounted()  - when component is unmounted.
....................................................................................
			 Global Directives
.....................................................................................

Directives are created as part of Application object

import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .provide('company', 'google')
    .directive('focus', (element, binding) => {
        console.log('directive => ', element)
        element.focus()
    })
    .directive('highlight', (element, binding) => {
        element.addEventListener('mousemove', (evt) => {
            //element.style.backgroundColor = 'yellow'
            highLight('yellow')
        })
        //remove style
        element.addEventListener('mouseleave', (evt) => {
            // element.style.backgroundColor = null
            highLight(null)
        })
        const highLight = (color) => {
            element.style.backgroundColor = color
        }
    })
    .mount('#app')

App.vue
<script setup>

</script>
<template>
    <input v-focus />
    <h1 v-highlight>Highlight</h1>
</template>

How to pass parameter to directive?

<input v-bind:value="msg">
                      |
		    Parameter				
  
import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .provide('company', 'google')
    .directive('focus', (element, binding) => {
        console.log('directive => ', element)
        element.focus()
    })
    .directive('highlight', (element, binding) => {
      
        //set inital color:
        element.style.backgroundColor = binding.value
        element.addEventListener('mousemove', (evt) => {
            //element.style.backgroundColor = 'yellow'
            highLight('yellow')
        })
        //remove style
        element.addEventListener('mouseleave', (evt) => {
            // element.style.backgroundColor = null
            highLight(null)
        })
        const highLight = (color) => {
            element.style.backgroundColor = color
        }
    })
    .mount('#app')
....................................................................................
			   Plugins
....................................................................................
What is plugin?

 Plugins are self contained code that usuallay add app-top level functionality to Vue.
Most of third party libs are integrated as plugin with vue echo system eg: Vue-router
Statement management libs like vuex,Pinia.

Plugins are distribtued as npm modules, in order to use plugins, we have to do two things

1.install plugin as npm moudle

 npm install vue-router@4

2.Integrate with Application object

const app =createApp(App)

//directives
app.directive('demo',{})
//components
app.components('component',{})

//plugins
app.use(myPlugin)
app.use(router)

app.mount("#app");

....................................................................................
How to write plugins?

Step 1:

src/plugins/myPlugin.js
//UpperCase  plugin
export const myPlugin = {
    install(app, options) {
        //configure application
        //plugin logic: plugin reads data 
        app.config.globalProperties.$uppercase = key => {
            return key.toUpperCase();
        }
    }
};

Step 2 :
Register plugin in app object

import { createApp } from 'vue'
import App from './App.vue'
import { myPlugin } from './plugins/myplugin'

createApp(App)
    .use(myPlugin)
    .mount('#app')


Step 3: 
Use Plugin functionality inside app

<script setup>
</script>
<template>
  <h1>{{$uppercase('hello,how are you')}}</h1>
</template>
...................................................................................
			How to build SPA :Routing
....................................................................................

SPA is type of web application built for browsers, all navagations are done by javascript  , html only.

SPA is called client routing.

SPA core features:

1.all navagation is controlled inside browser only
2.From the server we get only data via apis as json format
3.In spa, only we have one physical page called landing page /home page
4.Name of the landing page would be "index.html"
5.Rest of application page are called "virtual pages" which are created by js  dynamically we call "components"
6.navigation is controlled by javascript objects called "location and histroy objects"
7.Frameworks for routing is built on the top of these objects only.
8.in order to build routing we need "HTML 5" 


Routing can be implemented using plain js,html5,ajax,css3 itself, but in large scale we need framework, Vue supports official "vue router" which is supplied as "plugin"



Router implementation without Router lib:

<script setup>
import HelloWorld from './components/HelloWorld.vue';
import Home from './components/Home.vue'
import { ref, computed } from 'vue'
//route config
const routes = {
  '/': Home,
  '/hello': HelloWorld
}
//Access path
const currentPath = ref(window.location.hash)

//track path changes
window.addEventListener('hashchange', () => {
  currentPath.value = window.location.hash
})
//current view
const currentView = computed(() => {
  return routes[currentPath.value.slice(1) || '/']
})

</script>
<template>
  <!-- Navigation links -->
  <div>
    <ul>
      <li>
        <a href="#/">Home</a>
      </li>
      <li>
        <a href="#/hello">Hello</a>
      </li>
    </ul>
    <component :is="currentView" />
  </div>
</template>


http://localhost:3000/#/


Vue offers official vue router lib, using that lib how to build spa application?


There are two ways to add router to vue app

For existing vue app
npm install vue-router@4

for app which begins new project

Web Application url pattern:

1.static url
 http://www.example.com/products.html / products.pdf
2.dynamic web url
 http://www.example.com/products.do /products.jsp | products.aspx | products.php
3.Web service url - REST Api
 http://www.example.com/api/products =>json
4.SPA Web url
SPA URL Patterns:
................
1.web url - looks like web service url
   http://www.example.com/hello /products
2.hash url pattern-  
http://www.example.com/index.html#hello |#products

Steps:

router/index.js
import Home from '../components/Home.vue'
import HelloWorld from '../components/HelloWorld.vue';
import { createRouter, createWebHistory } from 'vue-router'


//route configuration
const routes = [
    {
        path: '/',
        component: Home
    },
    {
        path: '/hello',
        component: HelloWorld
    }
]
//create router object
const router = createRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes
})

export default router;

2.main.js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'

createApp(App)
    .use(router)
    .mount('#app')


3.App.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router'
</script>
<template>
    <div>
        <!-- Menu Bar -->
        <nav>
            <RouterLink to="/">Home</RouterLink>
            <RouterLink to="/hello">Hello</RouterLink>
        </nav>
        <!-- Place Holder to display view based on route change -->
        <RouterView></RouterView>
    </div>
</template>
....................................................................................

URL patterns:

static url
 '/hello'
dynamic url
 '/greet/:message'

Dynamic Route parameter like message variable if you want to read inside component.

if you are in old vue , there is object this.$route

if you are in vue 3, composition api, with setup attribute/ function, we have  composobale apis

useRouter
useRoute - exposes all url related apis , like reading parameters

"$route and $router are built in objects which can be still used inside template without using useRouter and useRoute api"


components/Greeter.vue

<script setup>
import { watch,ref } from 'vue';
import { useRoute } from 'vue-router';
//Composable api to read params,query
const route = useRoute()


</script>
<template>
    <h1>{{ route.params.message }}</h1>
    <!-- Directly you can access route information inside template -->
    <h1>{{ $route.params.message }}</h1>

</template>

router/index.js
import Greeter from '../components/Greeter.vue'
import { createRouter, createWebHistory } from 'vue-router'


//route configuration
const routes = [
   {
        path: '/greet/:message',
        component: Greeter
    }
]
//create router object
const router = createRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes
})

export default router;
....................................................................................

Not Found:
if any url match is statisfied, we need to map to certain url

  {
        path: '/:pathMatch(.*)*',
        name:'NotFound',
        component: NotFound
    }
...................................................................................
			   path match expression

Vue router inspired from "express" js routing model

static
/users
dynamic

/users/:id

Rules : regular expressions

//order id must be number
/orders/:orderId(\\+d) 

/orders/:orderId? - optional parameter

Valid url patterns
/orders 
/orders/1

...................................................................................
			Nested routing
...................................................................................

user
 |
 profile
 post
 comments

/user/ram/profile
/user/ram/posts
/user/ram/comments


import Home from '../components/Home.vue'
import Greeter from '../components/Greeter.vue'
import NotFound from '../components/NotFound.vue'
import HelloWorld from '../components/HelloWorld.vue';
import User from '../components/User.vue'
import UserProfile from '../components/UserProfile.vue'
import UserPost from '../components/UserPost.vue'

import { createRouter, createWebHistory } from 'vue-router'


//route configuration
const routes = [
    {
        path: '/',
        component: Home
    }
    {
        path: '/user/:name',
        component: User,
        //nested routing
        children: [
            {
                path: 'profile',
                component: UserProfile
            },
            {
                path: 'posts',
                component: UserPost
            }
        ]
    },
    //will match everything and put under
    {
        path: '/:pathMatch(.*)*',
        name: 'NotFound',
        component: NotFound
    }

]
//create router object
const router = createRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes
})

export default router;


App.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router'
</script>
<template>
    <div>
        <!-- Menu Bar -->
        <nav>
            <RouterLink to="/">Home</RouterLink>
            <RouterLink to="/hello">Hello</RouterLink>
            <RouterLink to="/user/ram">User</RouterLink>

        </nav>
        <!-- Place Holder to display view based on route change -->
        <RouterView></RouterView>
    </div>
</template>

User.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router'

</script>
<template>
    <h1>User</h1>
    <h1>{{ $route.params.name }} {{$route.path}} {{$route.fullPath}}</h1>
    <nav>
        <RouterLink to="/user/ram/profile">Profile</RouterLink>
        <RouterLink to="/user/ram/posts">Posts</RouterLink>
    </nav>
    <!-- Nested View -->
    <RouterView></RouterView>
</template>
.....................................................................................
			   Programmetic Navigation
.....................................................................................

Declarative routing is implemneted via "router-link", Programmetic routing is implemented via "Router" Object

Declarative:
<router-link to="profile">

Programmetic Routing
const router = useRouter()

router.push('url')
router.push({path:'url'})

  /greeter/foo => /greeter/:name
router.push({path:'url',params:{name:'foo'}})

//with query string
 /users?order='asc'
router.push({path:'url',query:{order:'asc'}})

eg:

List.vue
<script setup>
import { useRouter, useRoute } from 'vue-router';

const router = useRouter()
console.log(router)

const goToPage = () => {
    //redirect to HelloWorld Page
    router.push({ path: 'hello' })
}
</script>
<template>
    <button @click="goToPage">Go to HelloWorld</button>
    <button @click="$router.back">Back</button>

</template>

import Home from '../components/Home.vue'
import Greeter from '../components/Greeter.vue'
import NotFound from '../components/NotFound.vue'
import HelloWorld from '../components/HelloWorld.vue';
import User from '../components/User.vue'
import UserProfile from '../components/UserProfile.vue'
import UserPost from '../components/UserPost.vue'
import List from '../components/List.vue'

import { createRouter, createWebHistory } from 'vue-router'

router/index.js

//route configuration
const routes = [
    {
        path: '/',
        component: Home
    },
    {
        path: '/hello',
        component: HelloWorld
    },
    {
        path: '/greet/:message',
        component: Greeter
    },
    {
        path: '/list',
        component: List
    },
    {
        path: '/user/:name',
        component: User,
        //nested routing
        children: [
            {
                path: '/',
                component: UserProfile
            },
            {
                path: 'profile',
                component: UserProfile
            },
            {
                path: 'posts',
                component: UserPost
            }
        ]
    },
    //will match everything and put under
    {
        path: '/:pathMatch(.*)*',
        name: 'NotFound',
        component: NotFound
    }

]
//create router object
const router = createRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes
})

export default router;
....................................................................................
			   Named Routes

const routes = [
  {
    path:'/product/:id'
    component:Product
  }
 
]

<router-link to="/product/13">Product

Here we have to refer whole path, instead we can simply using names

const routes = [
  {
    path:'/product/:id'
    component:Product,
    name:'product' //this is unique identifer for route match
  }
 
]

<router-link :to="{name:'product',params:{}}">Product

<script setup>
import { RouterLink, RouterView } from 'vue-router'
</script>
<template>
    <div>
        <!-- Menu Bar -->
        <nav>
            <ul>
                <li>
                    <RouterLink to="/">Home</RouterLink>
                </li>
                <li>
                    <RouterLink to="/hello">Hello</RouterLink>
                </li>
                <li>
                    <RouterLink to="/user/ram">User</RouterLink>
                </li>
                <li>
                    <RouterLink :to="{ name: 'product' }">Product</RouterLink>
                </li>
            </ul>
        </nav>
        <!-- Place Holder to display view based on route change -->
        <RouterView></RouterView>
    </div>
</template>

import Home from '../components/Home.vue'
import Greeter from '../components/Greeter.vue'
import NotFound from '../components/NotFound.vue'
import HelloWorld from '../components/HelloWorld.vue';
import User from '../components/User.vue'
import UserProfile from '../components/UserProfile.vue'
import UserPost from '../components/UserPost.vue'
import List from '../components/List.vue'
import Product from '../components/Product.vue'

import { createRouter, createWebHistory } from 'vue-router'


//route configuration
const routes = [
    {
        path: '/',
        component: Home
    },
    {
        path: '/hello',
        component: HelloWorld
    },
    {
        path: '/product',
        component: Product,
        name:'product'
    },
    {
        path: '/greet/:message',
        component: Greeter
    },
    {
        path: '/list',
        component: List
    },
    {
        path: '/user/:name',
        component: User,
        //nested routing
        children: [
            {
                path: '/',
                component: UserProfile
            },
            {
                path: 'profile',
                component: UserProfile
            },
            {
                path: 'posts',
                component: UserPost
            }
        ]
    },
    //will match everything and put under
    {
        path: '/:pathMatch(.*)*',
        name: 'NotFound',
        component: NotFound
    }

]
//create router object
const router = createRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes
})

export default router;

Product.vue
<script setup>
</script>
<template>
    <h1>Product</h1>
    
</template>
.....................................................................................
			  Master details


Product
 |
 ------>   Product details
 ------
 
index.js
  {
        path: '/product',
        component: Product,
        name:'product'
    },
    {
        path: '/product/:id',
        component: ProductDetails,
    }


Product.vue
<script setup>
import { RouterLink } from 'vue-router';
import { reactive } from 'vue';

const PRODUCTS = [
    { id: 1, name: 'a1' },
    { id: 2, name: 'a2' },
    { id: 3, name: 'a3' },
    { id: 4, name: 'a4' },
    { id: 5, name: 'a5' },
    { id: 6, name: 'b6' },
    { id: 7, name: 'a90' },
    { id: 8, name: 'b45' },
    { id: 9, name: 'a23' },
    { id: 10, name: 'b12' }
]

const products = reactive(PRODUCTS)
</script>
<template>
    <h1>Product</h1>
    <ul>
        <li v-for="product of products">
            <span>
                <RouterLink :to="'/product/' + product.id">{{ product.name }}</RouterLink>
            </span>
        </li>

    </ul>
</template>	

Productdetails.vue
<script setup>
</script>
<template>
    <h1>{{ $route.params.id }} - Details</h1>
</template>
...................................................................................
			    Lazy Loading
.....................................................................................

When building spa apps with a bundler like webpack, which packs the entire app as single bundle, it becomes quite large, thus affects performance  of page load during inital render. in order to avoid such performance bottle necks, we can load  the files when a route is visited. ->Lazy loading.

How to implement lazy loading?

 {
        path: '/product/:id',
        //lazy loaded component
        component: import('../components/ProductDetails.vue')
    }
................................................................................
			      CSS

Vue supports global css 
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import './assets/base.css'

createApp(App)
    .use(router)
    .mount('#app')

Vue supports component sepcific css - scoped styles

with scoped
<style scoped>
h1 {
    color: blue
}
</style>

output:
<h1 data-v-1c354f03="">7 - Details</h1>

with out scoped
<style>
h1 {
    color: blue
}
</style>
<h1>7 - Details</h1>

The scoped attribute is very useful , this attaches a unique HTML 5 data attribute
selector to all of your styles, preventing them from colliding globally.
<script setup>
</script>
<template>
    <h1>{{ $route.params.id }} - Details</h1>
</template>
<style scoped>
h1 {
    color: blue
}
</style>
...................................................................................
			   Template Ref
....................................................................................

Vue never allows direct DOM access inside component, like accessing all dom properties such as style,target,listener......

There is key word called "ref" - reference to the dom element

<h1 ref="variable">Hello</h1>

<script setup>
import { onMounted, ref } from 'vue'
//ref is poniter to dom elements
const myheader = ref(null);

//we can access any element once it is mounted inside browser
onMounted(() => {
    //this hook is called once the dom is ready
    console.dir(myheader.value)

})

</script>
<template>
    <h1 ref="myheader">Hello</h1>
</template>

Note:
dont over use template reference, only neccessary you have to use , which skips all vue render cycle.
....................................................................................
			Async Components With Suspense
.................................................................................

Async components are not loaded up front, rather which is loaded as chunk(small bundle), when ever it is necessary.

const component = defineAsyncComponent(()=>{
   import('./components/MyComponent.vue')
})

<script setup>
import { defineAsyncComponent } from 'vue';

const HelloWorld = defineAsyncComponent(() => import('./components/HelloWorld.vue'))

</script>
<template>
    <HelloWorld />
</template>

.........................

HelloWorld.vue
<script setup>
defineProps({
  msg: {
    type: String,
    required: true
  }
})
function delay() {
  return new Promise((resolve, rejec) => {
    setTimeout(resolve, 10000, 'I delay the process')
  })
}
const output = await delay()

</script>

<template>
  <div class="greetings">
    <h1 class="green">{{ msg }} {{output}}</h1>
    <h3>
      You’ve successfully created a project with
      <a target="_blank" href="https://vitejs.dev/">Vite</a> +
      <a target="_blank" href="https://vuejs.org/">Vue 3</a>.
    </h3>
  </div>
</template>

<style scoped>
h1 {
  font-weight: 500;
  font-size: 2.6rem;
  top: -10px;
}

h3 {
  font-size: 1.2rem;
}

.greetings h1,
.greetings h3 {
  text-align: center;
}

@media (min-width: 1024px) {

  .greetings h1,
  .greetings h3 {
    text-align: left;
  }
}
</style>
...

<script setup>
import { defineAsyncComponent, Suspense } from 'vue';

const HelloWorld = defineAsyncComponent(() => import('./components/HelloWorld.vue'))

const message = 'Hello Async component'
</script>
<template>
    <Suspense>
        <HelloWorld :msg="message" />
        <!-- This is fallback component when component takes more time to load -->
        <template #fallback>
            <h1>Loading...</h1>
        </template>
    </Suspense>
</template>
.....................................................................................
			   Animations
.....................................................................................

vue Provides two implmentation for animation

1.Transition -  Built in component
2.TransitionGroup - Built in component 

For Animations

Stages:

1.if user enters / leaves into the screen.

In General animtations are implemented behind the scene using "CSS 3 advanced classes"

Vue offers built in css based component for implementing basic animation features.

<script setup>
import { ref } from 'vue';

const show = ref(true)

</script>
<template>
    <button @click="show = !show">Toggle</button>
    <Transition name="fade">
        <p v-if="show">
            Hey , How are you?
        </p>
    </Transition>
</template>
<style>
/* Transition styles */
.v-enter-active,
.v-leave-active {
    transition: opacity 0.5s ease;
}

.v-enter-from,
.v-leave-to {
    opacity: 0;
}
</style>

...................

<script setup>
import { ref } from 'vue'
const show = ref(true)
</script>

<template>
	<button @click="show = !show">Toggle</button>
  <Transition name="slide-fade">
    <p v-if="show">hello</p>
  </Transition>
</template>

<style>
.slide-fade-enter-active {
  transition: all 0.3s ease-out;
}

.slide-fade-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}

.slide-fade-enter-from,
.slide-fade-leave-to {
  transform: translateX(20px);
  opacity: 0;
}
</style>
.....................................................................................
			State Management using Pinia
....................................................................................

State management is nothing but Managining state(data) of application.

State(Data) is represented and managed in various places

1.inside component - via reactive properties
2.outside component within component tree - via props(parent to child)
3.outside component within component tree -via events(child to parent)

4.Sharing data globally.

component

state
  The state, the source of truth that drives our application
view
 The view, a declarative mapping of the state
actions
 The actions, the possible ways the state could change in reaction to user inputs from the view


Component state,actions,view:
<script setup>
import { ref } from 'vue';

//state - reactive state
const counter = ref(0)
//actions
const onIncrement = () => counter.value++

</script>
<template>
    <!-- View -->
    <div>
        <h1>Counter {{ counter }}</h1>
        <!-- User interacts  -->
        <button @click="onIncrement">+</button>
    </div>
</template>
<style scoped>
</style>
///////////////////////////////////////////////////////////////////////////////////
			 Separate state from the component


store/counterstore.js
import { ref } from 'vue';

// //state - reactive state
// export const counterStore = ref(0)

// //actions
// export const onIncrement = () => counterStore.value++
const store = {
    state: {
        counterStore: ref(0)
    },
    actions: {
        onIncrement() {
            //console.log(store.state.counterStore.value)
            store.state.counterStore.value++
        }
    }
}

export default store;

//
components/Counter.vue
<script setup>
import { ref } from 'vue';
import counterStore from '../store/counterstore.js'

</script>
<template>
    <!-- View -->
    <div>
        <h1>Counter {{ counterStore.state.counterStore }}</h1>
        <!-- User interacts  -->
        <button @click="counterStore.actions.onIncrement">+</button>
    </div>
</template>
<style scoped>
</style>

//
App.vue
<script setup>
import counterStore from './store/counterstore.js'
import Counter from './components/Counter.vue'

</script>
<template>
    <!-- View -->
    <div>
        <h1>Counter {{ counterStore.state.counterStore }}</h1>
        <!-- User interacts  -->
        <button @click="counterStore.actions.onIncrement">+</button>
    </div>
    <h1>Counter Component</h1>
    <Counter></Counter>
</template>
<style scoped>
</style>
.................................................................................
			StateManagement libs - Pinia
.................................................................................
		
What is Pinia?

State management lib for managing state and its life cycle for vue applications.

Pinia is written for "VUE 3 compostion api model and Composable style", unlike VueX another statemanagement lib for vue 2 , which is written imperative style.

Pinia can work with both versions, but highly recommended for vue 3

Why Pinia?

1.Dev tool Support

2.HMR Support

3.Typescript support

4.SSR Support


How to start with Pinia?

npm install pinia


Since pinia is supplied as plugin, so we need to configure pinia
main.js
import { createApp } from 'vue'
import App from './App.vue'
import { createPinia } from 'pinia'

createApp(App)
  .use(createPinia())
    .mount('#app')
....................................................................................

Pinia Core Concepts:
....................

1.store
2.Actions
3.Getters

Store:
 Object  which encapsulate component's (state,actions (computed)), The state inside store is reactive by default.

Actions:
  Object which encapsulate components behaviour(methods)

Getters:
  Object which encapulate components computed properties


Store = {state + actions + getters}

Steps:

1.create store
   defineStore api from pinia to create store
//every store name starts with "use+StoreName"

import { defineStore } from "pinia";

//create store
export const useCounterStore = defineStore('counter', {
    //state
    state: () => {
        //return inital state
        return {
            count: 10
        }
    },
    //actions
    actions: {
        increment() {
            this.count++
        }
    },
    //getters (computed Properties)
    getters: {
        doubleIt: state => state.count * 2
    }
})

   
2.use store
<script setup>
//how to use store
import { useCounterStore } from './store/useCounterStore.js';
const counter = useCounterStore()

</script>
<template>
    <div>
        <h1>Pinia State Management App</h1>
        <h2>Counter {{counter.count}} Double Counter {{counter.doubleIt}}</h2>
        <button @click="counter.increment">+</button>
    </div>
</template>
<style>
</style>
....................................................................................
			Extra apis from the store


$reset
 method is used to reset to inital state.

<script setup>
//how to use store
import { useCounterStore } from './store/useCounterStore.js';
const counter = useCounterStore()

</script>
<template>
    <div>
        <h1>Pinia State Management App</h1>
        <h2>Counter {{ counter.count }} Double Counter {{ counter.doubleIt }}</h2>
        <button @click="counter.increment">+</button>
        <button @click="counter.$reset">Reset</button>

    </div>
</template>
<style>
</style>

$patch:

 You can mutate state directly, counter.value++, this can be done indirectly via $patch method

        <button @click="counter.$patch({
            count: counter.count + 1
        })">Patch</button>

............

Adding watcher on to the store:

 We can watch what is going on in the state mutations.

<script setup>
//how to use store
import { useCounterStore } from './store/useCounterStore.js';
const counter = useCounterStore()

//watch changes in the store
counter.$subscribe((mutation, state) => {
    console.log('Mutation=>', mutation, 'State=>', state)
})

</script>
<template>
    <div>
        <h1>Pinia State Management App</h1>
        <h2>Counter {{ counter.count }} Double Counter {{ counter.doubleIt }}</h2>
        <button @click="counter.increment">+</button>
        <button @click="counter.$reset">Reset</button>
        <button @click="counter.$patch({
            count: counter.count + 1
        })">Patch</button>


    </div>
</template>
<style>
</style>
....................................................................................
			 Async Operations - timer,ajax calls
.....................................................................................

//every store name starts with "use+StoreName"

import { defineStore } from "pinia";

//create store
export const useCounterStore = defineStore('counter', {
    //state
    state: () => {
        //return inital state
        return {
            count: 10,
        }
    },
    //actions
    actions: {
        increment() {
            this.count++
        },
        //async increment
        async incrementAsync() {
            let res = new Promise((resolve, reject) => {
                setTimeout(resolve, 1000, this.count)
            })

            this.count = await res + 1
        }
    },
    //getters (computed Properties)
    getters: {
        doubleIt: state => state.count * 2
    }
})
...................................................................................
				Ajax calls with Pinia
...................................................................................

store/useTodos.js
import { defineStore } from "pinia";


export const useTodosStore = defineStore('todos', {
    state: () => {
        return {
            todos: []
        }
    },
    actions: {
        async fetchTodos() {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos')
                const data = await response.json()
                this.todos = data

            }
            catch (err) {
                console.log(err)
            }
        }
    }
})

App.vue
<script setup>
import { onMounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useTodosStore } from './store/useTodos.js'

const TodosStore = useTodosStore();

//destructure of reactive properties(state)
const { todos } = storeToRefs(TodosStore)

//actions destructure
const { fetchTodos } = TodosStore

//after dom ready
onMounted(() => {
    //TodosStore.fetchTodos()
    fetchTodos()
})

</script>
<template>
    <h1>Todo App using Pinia</h1>
    <ul>
        <li v-for="todo of todos">
            <span>{{ todo.title }}</span>
        </li>
    </ul>
</template>
